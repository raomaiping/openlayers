{"version":3,"sources":["webpack:///./src/hooks/updateMapSize.js","webpack:///./node_modules/.pnpm/core-js@3.35.0/node_modules/core-js/internals/does-not-exceed-safe-integer.js","webpack:///./node_modules/.pnpm/core-js@3.35.0/node_modules/core-js/internals/is-array.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/format/XMLFeature.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/format/GPX.js","webpack:///./src/views/third-party-map-display/gpx/index.vue","webpack:///./src/views/third-party-map-display/gpx/index.vue?8afc","webpack:///./node_modules/.pnpm/core-js@3.35.0/node_modules/core-js/internals/array-set-length.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/format/xsd.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/flat/interpolate.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/MultiLineString.js","webpack:///./src/views/third-party-map-display/gpx/index.vue?9d56","webpack:///./node_modules/.pnpm/core-js@3.35.0/node_modules/core-js/modules/es.array.push.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/format/Feature.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/xml.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/LineString.js"],"names":["map","targetNode","document","querySelector","observer","MutationObserver","mutationsList","mutation","type","attributeName","i","length","updateSize","observe","attributes","childList","subtree","onBeforeUnmount","disconnect","$TypeError","TypeError","module","exports","it","classof","Array","isArray","argument","extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","p","prototype","hasOwnProperty","call","String","__","this","constructor","create","XMLFeature","_super","_this","xmlSerializer_","getType","readFeature","source","opt_options","doc","readFeatureFromDocument","readFeatureFromNode","features","readFeaturesFromDocument","node","readFeatures","readFeaturesFromNode","n","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","readGeometry","readGeometryFromDocument","readGeometryFromNode","readProjection","readProjectionFromDocument","readProjectionFromNode","dataProjection","writeFeature","feature","writeFeatureNode","serializeToString","writeFeatures","writeFeaturesNode","writeGeometry","geometry","writeGeometryNode","NAMESPACE_URIS","FEATURE_READER","readRte","readTrk","readWpt","GPX_PARSERS","LINK_PARSERS","GPX_SERIALIZERS","objectStack","options","properties","getProperties","context","getGeometry","lineString","getLayout","getCoordinates","parentNode","orderedKeys","RTE_SEQUENCE","namespaceURI","values","RTE_SERIALIZERS","multiLineString","getLineStrings","TRK_SEQUENCE","TRK_SERIALIZERS","point","writeWptType","GPX","readExtensions_","readExtensions","handleReadExtensions_","ii","extensionsNode","get","set","undefined","featureReader","localName","getReadOptions","adaptOptions","gpx","setAttributeNS","setAttribute","GPX_NODE_FACTORY","RTE_PARSERS","parseLink","parseExtensions","RTEPT_PARSERS","rteValues","appendCoordinate","TRK_PARSERS","TRKSEG_PARSERS","flatCoordinates","push","TRKPT_PARSERS","trkValues","WPT_PARSERS","LINK_SEQUENCE","LINK_SERIALIZERS","writeLink","RTEPT_TYPE_SEQUENCE","TRKSEG_SERIALIZERS","TRKSEG_NODE_FACTORY","WPT_TYPE_SEQUENCE","WPT_TYPE_SERIALIZERS","GEOMETRY_TYPE_TO_NODENAME","value","opt_nodeName","nodeName","layoutOptions","parseFloat","getAttribute","hasZ","hasM","applyLayoutOptions","ends","layout","GeometryLayout","XY","stride","XYZM","XYZ","XYM","href","LineString","Feature","setProperties","MultiLineString","coordinates","Point","link","coordinate","raster","TileLayer","attributions","ATTRIBUTIONS","url","MAPURL","maxZoom","style","Style","image","CircleStyle","fill","Fill","color","radius","stroke","Stroke","width","vector","VectorLayer","VectorSource","format","onMounted","Map","layers","target","getElementById","view","View","center","zoom","updateMapSize","displayFeatureInfo","pixel","forEachFeatureAtPixel","info","innerHTML","join","getTarget","cursor","on","evt","dragging","getEventPixel","originalEvent","__exports__","DESCRIPTORS","getOwnPropertyDescriptor","SILENT_ON_NON_WRITABLE_LENGTH_SET","defineProperty","writable","error","O","readBoolean","m","s","exec","readDateTime","dateTime","Date","parse","isNaN","readDecimal","readPositiveInteger","parseInt","readString","trim","writeBooleanTextNode","bool","writeStringTextNode","writeCDATASection","string","appendChild","createCDATASection","writeDateTimeTextNode","date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","createTextNode","writeDecimalTextNode","decimal","toPrecision","writeNonNegativeIntegerTextNode","nonNegativeInteger","toString","interpolatePoint","offset","end","fraction","opt_dest","opt_dimension","o","t","x1","y1","length_1","cumulativeLengths","x2","y2","Math","sqrt","index","dimension","dest","NaN","lineStringCoordinateAtM","extrapolate","slice","lo","hi","mid","m0","lineStringsCoordinateAtM","interpolate","opt_layout","opt_ends","ends_","maxDelta_","maxDeltaRevision_","setCoordinates","setFlatCoordinates","lineStrings","getFlatCoordinates","appendLineString","changed","clone","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","getCoordinateAtM","opt_extrapolate","opt_interpolate","getEnds","getLineString","getFlatMidpoints","midpoints","midpoint","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","intersectsExtent","extent","setLayout","$","toObject","lengthOfArrayLike","setArrayLength","doesNotExceedSafeInteger","proto","arity","forced","fails","properErrorOnNonWritableLength","item","len","argCount","arguments","FeatureFormat","defaultFeatureProjection","supportedMediaTypes","getUnits","TILE_PIXELS","setWorldExtent","featureProjection","transformGeometryWithOptions","write","transformed","transform","decimals","power_1","pow","applyTransform","round","XML_SCHEMA_INSTANCE_URI","createElementNS","qualifiedName","getDocument","getAllTextContent","normalizeWhitespace","getAllTextContent_","accumulator","CDATA_SECTION_NODE","TEXT_NODE","nodeValue","replace","isDocument","object","xml","DOMParser","parseFromString","makeArrayExtender","valueReader","opt_this","array","makeArrayPusher","makeReplacer","makeObjectPropertySetter","opt_property","makeChildAppender","nodeWriter","makeArraySerializer","serializersNS","nodeFactory","serializers","makeSimpleNodeFactory","serialize","opt_namespaceURI","fixedNodeName","OBJECT_PROPERTY_NODE_FACTORY","makeSequence","sequence","makeStructureNS","namespaceURIs","structure","opt_structureNS","structureNS","parseNode","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pushParseAndPop","pop","opt_keys","pushSerializeAndPop","getXMLSerializer","XMLSerializer","document_","implementation","createDocument","flatMidpoint_","flatMidpointRevision_","forEachSegment","callback","getCoordinateAt","getLength","getFlatMidpoint"],"mappings":"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","file":"js/chunk-5ce82b98.c95abcde.js","sourcesContent":["import { onBeforeUnmount } from \"vue\";\n\n/**\n * 监听侧边栏，侧边栏发生变化更新地图\n * @param {ol.Map} map 地图实例\n */\nexport default (...map) => {\n  // 选择需要观察变动的节点\n  const targetNode = document.querySelector(\n    \".el-aside .menu .el-scrollbar__view\"\n  );\n  // 观察器的配置（需要观察什么变动）\n  const config = { attributes: true, childList: true, subtree: true };\n  // 当观察到变动时执行的回调函数\n  const callback = function (mutationsList) {\n    // Use traditional 'for loops' for IE 11\n    for (let mutation of mutationsList) {\n      if (mutation.type === \"childList\") {\n        // console.log(\"已添加或删除子节点。\");\n      } else if (\n        mutation.type === \"attributes\" &&\n        mutation.attributeName === \"style\"\n      ) {\n        for (let i = 0; i < map.length; i++) {\n          map[i].updateSize();\n        }\n\n        // console.log(\"这个 \" + mutation.attributeName + \" 属性被修改。\");\n      }\n    }\n  };\n  // 创建一个观察器实例并传入回调函数\n  const observer = new MutationObserver(callback);\n\n  // 以上述配置开始观察目标节点\n  observer.observe(targetNode, config);\n\n  //卸载前\n  onBeforeUnmount(() => {\n    observer.disconnect();\n  });\n};\n","'use strict';\nvar $TypeError = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n\nmodule.exports = function (it) {\n  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');\n  return it;\n};\n","'use strict';\nvar classof = require('../internals/classof-raw');\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) === 'Array';\n};\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/XMLFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport { abstract } from '../util.js';\nimport { extend } from '../array.js';\nimport { getXMLSerializer, isDocument, parse } from '../xml.js';\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nvar XMLFeature = /** @class */ (function (_super) {\n    __extends(XMLFeature, _super);\n    function XMLFeature() {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {XMLSerializer}\n         * @private\n         */\n        _this.xmlSerializer_ = getXMLSerializer();\n        return _this;\n    }\n    /**\n     * @return {import(\"./Feature.js\").Type} Format.\n     */\n    XMLFeature.prototype.getType = function () {\n        return 'xml';\n    };\n    /**\n     * Read a single feature.\n     *\n     * @param {Document|Element|Object|string} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     * @api\n     */\n    XMLFeature.prototype.readFeature = function (source, opt_options) {\n        if (!source) {\n            return null;\n        }\n        else if (typeof source === 'string') {\n            var doc = parse(source);\n            return this.readFeatureFromDocument(doc, opt_options);\n        }\n        else if (isDocument(source)) {\n            return this.readFeatureFromDocument(\n            /** @type {Document} */ (source), opt_options);\n        }\n        else {\n            return this.readFeatureFromNode(\n            /** @type {Element} */ (source), opt_options);\n        }\n    };\n    /**\n     * @param {Document} doc Document.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n    XMLFeature.prototype.readFeatureFromDocument = function (doc, opt_options) {\n        var features = this.readFeaturesFromDocument(doc, opt_options);\n        if (features.length > 0) {\n            return features[0];\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n    XMLFeature.prototype.readFeatureFromNode = function (node, opt_options) {\n        return null; // not implemented\n    };\n    /**\n     * Read all features from a feature collection.\n     *\n     * @param {Document|Element|Object|string} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     * @api\n     */\n    XMLFeature.prototype.readFeatures = function (source, opt_options) {\n        if (!source) {\n            return [];\n        }\n        else if (typeof source === 'string') {\n            var doc = parse(source);\n            return this.readFeaturesFromDocument(doc, opt_options);\n        }\n        else if (isDocument(source)) {\n            return this.readFeaturesFromDocument(\n            /** @type {Document} */ (source), opt_options);\n        }\n        else {\n            return this.readFeaturesFromNode(\n            /** @type {Element} */ (source), opt_options);\n        }\n    };\n    /**\n     * @param {Document} doc Document.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @protected\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     */\n    XMLFeature.prototype.readFeaturesFromDocument = function (doc, opt_options) {\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        var features = [];\n        for (var n = doc.firstChild; n; n = n.nextSibling) {\n            if (n.nodeType == Node.ELEMENT_NODE) {\n                extend(features, this.readFeaturesFromNode(/** @type {Element} */ (n), opt_options));\n            }\n        }\n        return features;\n    };\n    /**\n     * @abstract\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @protected\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     */\n    XMLFeature.prototype.readFeaturesFromNode = function (node, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read a single geometry from a source.\n     *\n     * @param {Document|Element|Object|string} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    XMLFeature.prototype.readGeometry = function (source, opt_options) {\n        if (!source) {\n            return null;\n        }\n        else if (typeof source === 'string') {\n            var doc = parse(source);\n            return this.readGeometryFromDocument(doc, opt_options);\n        }\n        else if (isDocument(source)) {\n            return this.readGeometryFromDocument(\n            /** @type {Document} */ (source), opt_options);\n        }\n        else {\n            return this.readGeometryFromNode(\n            /** @type {Element} */ (source), opt_options);\n        }\n    };\n    /**\n     * @param {Document} doc Document.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    XMLFeature.prototype.readGeometryFromDocument = function (doc, opt_options) {\n        return null; // not implemented\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    XMLFeature.prototype.readGeometryFromNode = function (node, opt_options) {\n        return null; // not implemented\n    };\n    /**\n     * Read the projection from the source.\n     *\n     * @param {Document|Element|Object|string} source Source.\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     * @api\n     */\n    XMLFeature.prototype.readProjection = function (source) {\n        if (!source) {\n            return null;\n        }\n        else if (typeof source === 'string') {\n            var doc = parse(source);\n            return this.readProjectionFromDocument(doc);\n        }\n        else if (isDocument(source)) {\n            return this.readProjectionFromDocument(/** @type {Document} */ (source));\n        }\n        else {\n            return this.readProjectionFromNode(/** @type {Element} */ (source));\n        }\n    };\n    /**\n     * @param {Document} doc Document.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n    XMLFeature.prototype.readProjectionFromDocument = function (doc) {\n        return this.dataProjection;\n    };\n    /**\n     * @param {Element} node Node.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n    XMLFeature.prototype.readProjectionFromNode = function (node) {\n        return this.dataProjection;\n    };\n    /**\n     * Encode a feature as string.\n     *\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string} Encoded feature.\n     */\n    XMLFeature.prototype.writeFeature = function (feature, opt_options) {\n        var node = this.writeFeatureNode(feature, opt_options);\n        return this.xmlSerializer_.serializeToString(node);\n    };\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n     * @protected\n     * @return {Node} Node.\n     */\n    XMLFeature.prototype.writeFeatureNode = function (feature, opt_options) {\n        return null; // not implemented\n    };\n    /**\n     * Encode an array of features as string.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string} Result.\n     * @api\n     */\n    XMLFeature.prototype.writeFeatures = function (features, opt_options) {\n        var node = this.writeFeaturesNode(features, opt_options);\n        return this.xmlSerializer_.serializeToString(node);\n    };\n    /**\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n     * @return {Node} Node.\n     */\n    XMLFeature.prototype.writeFeaturesNode = function (features, opt_options) {\n        return null; // not implemented\n    };\n    /**\n     * Encode a geometry as string.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string} Encoded geometry.\n     */\n    XMLFeature.prototype.writeGeometry = function (geometry, opt_options) {\n        var node = this.writeGeometryNode(geometry, opt_options);\n        return this.xmlSerializer_.serializeToString(node);\n    };\n    /**\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n     * @return {Node} Node.\n     */\n    XMLFeature.prototype.writeGeometryNode = function (geometry, opt_options) {\n        return null; // not implemented\n    };\n    return XMLFeature;\n}(FeatureFormat));\nexport default XMLFeature;\n//# sourceMappingURL=XMLFeature.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/GPX\n */\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport Point from '../geom/Point.js';\nimport XMLFeature from './XMLFeature.js';\nimport { OBJECT_PROPERTY_NODE_FACTORY, XML_SCHEMA_INSTANCE_URI, createElementNS, makeArrayPusher, makeArraySerializer, makeChildAppender, makeObjectPropertySetter, makeSequence, makeSimpleNodeFactory, makeStructureNS, parseNode, pushParseAndPop, pushSerializeAndPop, } from '../xml.js';\nimport { get as getProjection } from '../proj.js';\nimport { includes } from '../array.js';\nimport { readDateTime, readDecimal, readPositiveInteger, readString, writeDateTimeTextNode, writeDecimalTextNode, writeNonNegativeIntegerTextNode, writeStringTextNode, } from './xsd.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n/**\n * @const\n * @type {Array<null|string>}\n */\nvar NAMESPACE_URIS = [\n    null,\n    'http://www.topografix.com/GPX/1/0',\n    'http://www.topografix.com/GPX/1/1',\n];\n/**\n * @const\n * @type {string}\n */\nvar SCHEMA_LOCATION = 'http://www.topografix.com/GPX/1/1 ' +\n    'http://www.topografix.com/GPX/1/1/gpx.xsd';\n/**\n * @const\n * @type {Object<string, function(Node, Array<*>): (Feature|undefined)>}\n */\nvar FEATURE_READER = {\n    'rte': readRte,\n    'trk': readTrk,\n    'wpt': readWpt,\n};\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar GPX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'rte': makeArrayPusher(readRte),\n    'trk': makeArrayPusher(readTrk),\n    'wpt': makeArrayPusher(readWpt),\n});\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'text': makeObjectPropertySetter(readString, 'linkText'),\n    'type': makeObjectPropertySetter(readString, 'linkType'),\n});\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nvar GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n    'rte': makeChildAppender(writeRte),\n    'trk': makeChildAppender(writeTrk),\n    'wpt': makeChildAppender(writeWpt),\n});\n/**\n * @typedef {Object} Options\n * @property {function(Feature, Node):void} [readExtensions] Callback function\n * to process `extensions` nodes. To prevent memory leaks, this callback function must\n * not store any references to the node. Note that the `extensions`\n * node is not allowed in GPX 1.0. Moreover, only `extensions`\n * nodes from `wpt`, `rte` and `trk` can be processed, as those are\n * directly mapped to a feature.\n */\n/**\n * @typedef {Object} LayoutOptions\n * @property {boolean} [hasZ] HasZ.\n * @property {boolean} [hasM] HasM.\n */\n/**\n * @classdesc\n * Feature format for reading and writing data in the GPX format.\n *\n * Note that {@link module:ol/format/GPX~GPX#readFeature} only reads the first\n * feature of the source.\n *\n * When reading, routes (`<rte>`) are converted into LineString geometries, and\n * tracks (`<trk>`) into MultiLineString. Any properties on route and track\n * waypoints are ignored.\n *\n * When writing, LineString geometries are output as routes (`<rte>`), and\n * MultiLineString as tracks (`<trk>`).\n *\n * @api\n */\nvar GPX = /** @class */ (function (_super) {\n    __extends(GPX, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function GPX(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.dataProjection = getProjection('EPSG:4326');\n        /**\n         * @type {function(Feature, Node): void|undefined}\n         * @private\n         */\n        _this.readExtensions_ = options.readExtensions;\n        return _this;\n    }\n    /**\n     * @param {Array<Feature>} features List of features.\n     * @private\n     */\n    GPX.prototype.handleReadExtensions_ = function (features) {\n        if (!features) {\n            features = [];\n        }\n        for (var i = 0, ii = features.length; i < ii; ++i) {\n            var feature = features[i];\n            if (this.readExtensions_) {\n                var extensionsNode = feature.get('extensionsNode_') || null;\n                this.readExtensions_(feature, extensionsNode);\n            }\n            feature.set('extensionsNode_', undefined);\n        }\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n    GPX.prototype.readFeatureFromNode = function (node, opt_options) {\n        if (!includes(NAMESPACE_URIS, node.namespaceURI)) {\n            return null;\n        }\n        var featureReader = FEATURE_READER[node.localName];\n        if (!featureReader) {\n            return null;\n        }\n        var feature = featureReader(node, [\n            this.getReadOptions(node, opt_options),\n        ]);\n        if (!feature) {\n            return null;\n        }\n        this.handleReadExtensions_([feature]);\n        return feature;\n    };\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     */\n    GPX.prototype.readFeaturesFromNode = function (node, opt_options) {\n        if (!includes(NAMESPACE_URIS, node.namespaceURI)) {\n            return [];\n        }\n        if (node.localName == 'gpx') {\n            /** @type {Array<Feature>} */\n            var features = pushParseAndPop([], GPX_PARSERS, node, [\n                this.getReadOptions(node, opt_options),\n            ]);\n            if (features) {\n                this.handleReadExtensions_(features);\n                return features;\n            }\n            else {\n                return [];\n            }\n        }\n        return [];\n    };\n    /**\n     * Encode an array of features in the GPX format as an XML node.\n     * LineString geometries are output as routes (`<rte>`), and MultiLineString\n     * as tracks (`<trk>`).\n     *\n     * @param {Array<Feature>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n     * @return {Node} Node.\n     * @api\n     */\n    GPX.prototype.writeFeaturesNode = function (features, opt_options) {\n        opt_options = this.adaptOptions(opt_options);\n        //FIXME Serialize metadata\n        var gpx = createElementNS('http://www.topografix.com/GPX/1/1', 'gpx');\n        var xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n        gpx.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n        gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);\n        gpx.setAttribute('version', '1.1');\n        gpx.setAttribute('creator', 'OpenLayers');\n        pushSerializeAndPop(\n        /** @type {import(\"../xml.js\").NodeStackItem} */\n        ({ node: gpx }), GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);\n        return gpx;\n    };\n    return GPX;\n}(XMLFeature));\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar RTE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'name': makeObjectPropertySetter(readString),\n    'cmt': makeObjectPropertySetter(readString),\n    'desc': makeObjectPropertySetter(readString),\n    'src': makeObjectPropertySetter(readString),\n    'link': parseLink,\n    'number': makeObjectPropertySetter(readPositiveInteger),\n    'extensions': parseExtensions,\n    'type': makeObjectPropertySetter(readString),\n    'rtept': parseRtePt,\n});\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'ele': makeObjectPropertySetter(readDecimal),\n    'time': makeObjectPropertySetter(readDateTime),\n});\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar TRK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'name': makeObjectPropertySetter(readString),\n    'cmt': makeObjectPropertySetter(readString),\n    'desc': makeObjectPropertySetter(readString),\n    'src': makeObjectPropertySetter(readString),\n    'link': parseLink,\n    'number': makeObjectPropertySetter(readPositiveInteger),\n    'type': makeObjectPropertySetter(readString),\n    'extensions': parseExtensions,\n    'trkseg': parseTrkSeg,\n});\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'trkpt': parseTrkPt,\n});\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'ele': makeObjectPropertySetter(readDecimal),\n    'time': makeObjectPropertySetter(readDateTime),\n});\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nvar WPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n    'ele': makeObjectPropertySetter(readDecimal),\n    'time': makeObjectPropertySetter(readDateTime),\n    'magvar': makeObjectPropertySetter(readDecimal),\n    'geoidheight': makeObjectPropertySetter(readDecimal),\n    'name': makeObjectPropertySetter(readString),\n    'cmt': makeObjectPropertySetter(readString),\n    'desc': makeObjectPropertySetter(readString),\n    'src': makeObjectPropertySetter(readString),\n    'link': parseLink,\n    'sym': makeObjectPropertySetter(readString),\n    'type': makeObjectPropertySetter(readString),\n    'fix': makeObjectPropertySetter(readString),\n    'sat': makeObjectPropertySetter(readPositiveInteger),\n    'hdop': makeObjectPropertySetter(readDecimal),\n    'vdop': makeObjectPropertySetter(readDecimal),\n    'pdop': makeObjectPropertySetter(readDecimal),\n    'ageofdgpsdata': makeObjectPropertySetter(readDecimal),\n    'dgpsid': makeObjectPropertySetter(readPositiveInteger),\n    'extensions': parseExtensions,\n});\n/**\n * @const\n * @type {Array<string>}\n */\nvar LINK_SEQUENCE = ['text', 'type'];\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nvar LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n    'text': makeChildAppender(writeStringTextNode),\n    'type': makeChildAppender(writeStringTextNode),\n});\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nvar RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n    'name',\n    'cmt',\n    'desc',\n    'src',\n    'link',\n    'number',\n    'type',\n    'rtept',\n]);\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nvar RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n    'name': makeChildAppender(writeStringTextNode),\n    'cmt': makeChildAppender(writeStringTextNode),\n    'desc': makeChildAppender(writeStringTextNode),\n    'src': makeChildAppender(writeStringTextNode),\n    'link': makeChildAppender(writeLink),\n    'number': makeChildAppender(writeNonNegativeIntegerTextNode),\n    'type': makeChildAppender(writeStringTextNode),\n    'rtept': makeArraySerializer(makeChildAppender(writeWptType)),\n});\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nvar RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['ele', 'time']);\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nvar TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n    'name',\n    'cmt',\n    'desc',\n    'src',\n    'link',\n    'number',\n    'type',\n    'trkseg',\n]);\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nvar TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n    'name': makeChildAppender(writeStringTextNode),\n    'cmt': makeChildAppender(writeStringTextNode),\n    'desc': makeChildAppender(writeStringTextNode),\n    'src': makeChildAppender(writeStringTextNode),\n    'link': makeChildAppender(writeLink),\n    'number': makeChildAppender(writeNonNegativeIntegerTextNode),\n    'type': makeChildAppender(writeStringTextNode),\n    'trkseg': makeArraySerializer(makeChildAppender(writeTrkSeg)),\n});\n/**\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nvar TRKSEG_NODE_FACTORY = makeSimpleNodeFactory('trkpt');\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nvar TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n    'trkpt': makeChildAppender(writeWptType),\n});\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nvar WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n    'ele',\n    'time',\n    'magvar',\n    'geoidheight',\n    'name',\n    'cmt',\n    'desc',\n    'src',\n    'link',\n    'sym',\n    'type',\n    'fix',\n    'sat',\n    'hdop',\n    'vdop',\n    'pdop',\n    'ageofdgpsdata',\n    'dgpsid',\n]);\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nvar WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n    'ele': makeChildAppender(writeDecimalTextNode),\n    'time': makeChildAppender(writeDateTimeTextNode),\n    'magvar': makeChildAppender(writeDecimalTextNode),\n    'geoidheight': makeChildAppender(writeDecimalTextNode),\n    'name': makeChildAppender(writeStringTextNode),\n    'cmt': makeChildAppender(writeStringTextNode),\n    'desc': makeChildAppender(writeStringTextNode),\n    'src': makeChildAppender(writeStringTextNode),\n    'link': makeChildAppender(writeLink),\n    'sym': makeChildAppender(writeStringTextNode),\n    'type': makeChildAppender(writeStringTextNode),\n    'fix': makeChildAppender(writeStringTextNode),\n    'sat': makeChildAppender(writeNonNegativeIntegerTextNode),\n    'hdop': makeChildAppender(writeDecimalTextNode),\n    'vdop': makeChildAppender(writeDecimalTextNode),\n    'pdop': makeChildAppender(writeDecimalTextNode),\n    'ageofdgpsdata': makeChildAppender(writeDecimalTextNode),\n    'dgpsid': makeChildAppender(writeNonNegativeIntegerTextNode),\n});\n/**\n * @const\n * @type {Object<string, string>}\n */\nvar GEOMETRY_TYPE_TO_NODENAME = {\n    'Point': 'wpt',\n    'LineString': 'rte',\n    'MultiLineString': 'trk',\n};\n/**\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [opt_nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nfunction GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {\n    var geometry = /** @type {Feature} */ (value).getGeometry();\n    if (geometry) {\n        var nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];\n        if (nodeName) {\n            var parentNode = objectStack[objectStack.length - 1].node;\n            return createElementNS(parentNode.namespaceURI, nodeName);\n        }\n    }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {LayoutOptions} layoutOptions Layout options.\n * @param {Element} node Node.\n * @param {!Object} values Values.\n * @return {Array<number>} Flat coordinates.\n */\nfunction appendCoordinate(flatCoordinates, layoutOptions, node, values) {\n    flatCoordinates.push(parseFloat(node.getAttribute('lon')), parseFloat(node.getAttribute('lat')));\n    if ('ele' in values) {\n        flatCoordinates.push(/** @type {number} */ (values['ele']));\n        delete values['ele'];\n        layoutOptions.hasZ = true;\n    }\n    else {\n        flatCoordinates.push(0);\n    }\n    if ('time' in values) {\n        flatCoordinates.push(/** @type {number} */ (values['time']));\n        delete values['time'];\n        layoutOptions.hasM = true;\n    }\n    else {\n        flatCoordinates.push(0);\n    }\n    return flatCoordinates;\n}\n/**\n * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates\n * and ends arrays by shrinking them accordingly (removing unused zero entries).\n *\n * @param {LayoutOptions} layoutOptions Layout options.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {Array<number>} [ends] Ends.\n * @return {import(\"../geom/GeometryLayout.js\").default} Layout.\n */\nfunction applyLayoutOptions(layoutOptions, flatCoordinates, ends) {\n    var layout = GeometryLayout.XY;\n    var stride = 2;\n    if (layoutOptions.hasZ && layoutOptions.hasM) {\n        layout = GeometryLayout.XYZM;\n        stride = 4;\n    }\n    else if (layoutOptions.hasZ) {\n        layout = GeometryLayout.XYZ;\n        stride = 3;\n    }\n    else if (layoutOptions.hasM) {\n        layout = GeometryLayout.XYM;\n        stride = 3;\n    }\n    if (stride !== 4) {\n        for (var i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {\n            flatCoordinates[i * stride] = flatCoordinates[i * 4];\n            flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];\n            if (layoutOptions.hasZ) {\n                flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];\n            }\n            if (layoutOptions.hasM) {\n                flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];\n            }\n        }\n        flatCoordinates.length = (flatCoordinates.length / 4) * stride;\n        if (ends) {\n            for (var i = 0, ii = ends.length; i < ii; i++) {\n                ends[i] = (ends[i] / 4) * stride;\n            }\n        }\n    }\n    return layout;\n}\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseLink(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    var href = node.getAttribute('href');\n    if (href !== null) {\n        values['link'] = href;\n    }\n    parseNode(LINK_PARSERS, node, objectStack);\n}\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseExtensions(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    values['extensionsNode_'] = node;\n}\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseRtePt(node, objectStack) {\n    var values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);\n    if (values) {\n        var rteValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        var flatCoordinates = /** @type {Array<number>} */ (rteValues['flatCoordinates']);\n        var layoutOptions = /** @type {LayoutOptions} */ (rteValues['layoutOptions']);\n        appendCoordinate(flatCoordinates, layoutOptions, node, values);\n    }\n}\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseTrkPt(node, objectStack) {\n    var values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);\n    if (values) {\n        var trkValues = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        var flatCoordinates = /** @type {Array<number>} */ (trkValues['flatCoordinates']);\n        var layoutOptions = /** @type {LayoutOptions} */ (trkValues['layoutOptions']);\n        appendCoordinate(flatCoordinates, layoutOptions, node, values);\n    }\n}\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseTrkSeg(node, objectStack) {\n    var values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    parseNode(TRKSEG_PARSERS, node, objectStack);\n    var flatCoordinates = \n    /** @type {Array<number>} */\n    (values['flatCoordinates']);\n    var ends = /** @type {Array<number>} */ (values['ends']);\n    ends.push(flatCoordinates.length);\n}\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Track.\n */\nfunction readRte(node, objectStack) {\n    var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n    var values = pushParseAndPop({\n        'flatCoordinates': [],\n        'layoutOptions': {},\n    }, RTE_PARSERS, node, objectStack);\n    if (!values) {\n        return undefined;\n    }\n    var flatCoordinates = \n    /** @type {Array<number>} */\n    (values['flatCoordinates']);\n    delete values['flatCoordinates'];\n    var layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);\n    delete values['layoutOptions'];\n    var layout = applyLayoutOptions(layoutOptions, flatCoordinates);\n    var geometry = new LineString(flatCoordinates, layout);\n    transformGeometryWithOptions(geometry, false, options);\n    var feature = new Feature(geometry);\n    feature.setProperties(values, true);\n    return feature;\n}\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Track.\n */\nfunction readTrk(node, objectStack) {\n    var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n    var values = pushParseAndPop({\n        'flatCoordinates': [],\n        'ends': [],\n        'layoutOptions': {},\n    }, TRK_PARSERS, node, objectStack);\n    if (!values) {\n        return undefined;\n    }\n    var flatCoordinates = \n    /** @type {Array<number>} */\n    (values['flatCoordinates']);\n    delete values['flatCoordinates'];\n    var ends = /** @type {Array<number>} */ (values['ends']);\n    delete values['ends'];\n    var layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);\n    delete values['layoutOptions'];\n    var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);\n    var geometry = new MultiLineString(flatCoordinates, layout, ends);\n    transformGeometryWithOptions(geometry, false, options);\n    var feature = new Feature(geometry);\n    feature.setProperties(values, true);\n    return feature;\n}\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Waypoint.\n */\nfunction readWpt(node, objectStack) {\n    var options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n    var values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);\n    if (!values) {\n        return undefined;\n    }\n    var layoutOptions = /** @type {LayoutOptions} */ ({});\n    var coordinates = appendCoordinate([], layoutOptions, node, values);\n    var layout = applyLayoutOptions(layoutOptions, coordinates);\n    var geometry = new Point(coordinates, layout);\n    transformGeometryWithOptions(geometry, false, options);\n    var feature = new Feature(geometry);\n    feature.setProperties(values, true);\n    return feature;\n}\n/**\n * @param {Element} node Node.\n * @param {string} value Value for the link's `href` attribute.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLink(node, value, objectStack) {\n    node.setAttribute('href', value);\n    var context = objectStack[objectStack.length - 1];\n    var properties = context['properties'];\n    var link = [properties['linkText'], properties['linkType']];\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */ ({ node: node }), LINK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, LINK_SEQUENCE);\n}\n/**\n * @param {Element} node Node.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeWptType(node, coordinate, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var parentNode = context.node;\n    var namespaceURI = parentNode.namespaceURI;\n    var properties = context['properties'];\n    //FIXME Projection handling\n    node.setAttributeNS(null, 'lat', String(coordinate[1]));\n    node.setAttributeNS(null, 'lon', String(coordinate[0]));\n    var geometryLayout = context['geometryLayout'];\n    switch (geometryLayout) {\n        case GeometryLayout.XYZM:\n            if (coordinate[3] !== 0) {\n                properties['time'] = coordinate[3];\n            }\n        // fall through\n        case GeometryLayout.XYZ:\n            if (coordinate[2] !== 0) {\n                properties['ele'] = coordinate[2];\n            }\n            break;\n        case GeometryLayout.XYM:\n            if (coordinate[2] !== 0) {\n                properties['time'] = coordinate[2];\n            }\n            break;\n        default:\n        // pass\n    }\n    var orderedKeys = node.nodeName == 'rtept'\n        ? RTEPT_TYPE_SEQUENCE[namespaceURI]\n        : WPT_TYPE_SEQUENCE[namespaceURI];\n    var values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    ({ node: node, 'properties': properties }), WPT_TYPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n/**\n * @param {Node} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeRte(node, feature, objectStack) {\n    var options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n    var properties = feature.getProperties();\n    var context = { node: node };\n    context['properties'] = properties;\n    var geometry = feature.getGeometry();\n    if (geometry.getType() == 'LineString') {\n        var lineString = /** @type {LineString} */ (transformGeometryWithOptions(geometry, true, options));\n        context['geometryLayout'] = lineString.getLayout();\n        properties['rtept'] = lineString.getCoordinates();\n    }\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];\n    var values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(context, RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n/**\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeTrk(node, feature, objectStack) {\n    var options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n    var properties = feature.getProperties();\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    var context = { node: node };\n    context['properties'] = properties;\n    var geometry = feature.getGeometry();\n    if (geometry.getType() == 'MultiLineString') {\n        var multiLineString = /** @type {MultiLineString} */ (transformGeometryWithOptions(geometry, true, options));\n        properties['trkseg'] = multiLineString.getLineStrings();\n    }\n    var parentNode = objectStack[objectStack.length - 1].node;\n    var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];\n    var values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(context, TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n/**\n * @param {Element} node Node.\n * @param {LineString} lineString LineString.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeTrkSeg(node, lineString, objectStack) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    var context = { node: node };\n    context['geometryLayout'] = lineString.getLayout();\n    context['properties'] = {};\n    pushSerializeAndPop(context, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);\n}\n/**\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeWpt(node, feature, objectStack) {\n    var options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n    var context = objectStack[objectStack.length - 1];\n    context['properties'] = feature.getProperties();\n    var geometry = feature.getGeometry();\n    if (geometry.getType() == 'Point') {\n        var point = /** @type {Point} */ (transformGeometryWithOptions(geometry, true, options));\n        context['geometryLayout'] = point.getLayout();\n        writeWptType(node, point.getCoordinates(), objectStack);\n    }\n}\nexport default GPX;\n//# sourceMappingURL=GPX.js.map","<template>\n  <div id=\"map\" class=\"map\"></div>\n  <div id=\"info\">&nbsp;</div>\n</template>\n\n<script setup>\n  import { onMounted } from \"vue\";\n  import \"ol/ol.css\";\n  import GPX from \"ol/format/GPX\";\n  import Map from \"ol/Map\";\n  import VectorSource from \"ol/source/Vector\";\n  import View from \"ol/View\";\n  import XYZ from \"ol/source/XYZ\";\n  import { Circle as CircleStyle, Fill, Stroke, Style } from \"ol/style\";\n  import { Tile as TileLayer, Vector as VectorLayer } from \"ol/layer\";\n  import { MAPURL, ATTRIBUTIONS } from \"@/constants\";\n  import updateMapSize from \"@/hooks/updateMapSize\";\n\n  const raster = new TileLayer({\n    source: new XYZ({\n      attributions: ATTRIBUTIONS,\n      url: MAPURL,\n      maxZoom: 20,\n    }),\n  });\n\n  const style = {\n    Point: new Style({\n      image: new CircleStyle({\n        fill: new Fill({\n          color: \"rgba(255,255,0,0.4)\",\n        }),\n        radius: 5,\n        stroke: new Stroke({\n          color: \"#ff0\",\n          width: 1,\n        }),\n      }),\n    }),\n    LineString: new Style({\n      stroke: new Stroke({\n        color: \"#f00\",\n        width: 3,\n      }),\n    }),\n    MultiLineString: new Style({\n      stroke: new Stroke({\n        color: \"#0f0\",\n        width: 3,\n      }),\n    }),\n  };\n\n  const vector = new VectorLayer({\n    source: new VectorSource({\n      url: \"data/gpx/fells_loop.gpx\",\n      format: new GPX(),\n    }),\n    style: function (feature) {\n      return style[feature.getGeometry().getType()];\n    },\n  });\n\n  onMounted(() => {\n    const map = new Map({\n      layers: [raster, vector],\n      target: document.getElementById(\"map\"),\n      view: new View({\n        center: [-7916041.528716288, 5228379.045749711],\n        zoom: 12,\n      }),\n    });\n    // 侧边栏变化更新地图\n    updateMapSize(map);\n    const displayFeatureInfo = function (pixel) {\n      const features = [];\n      map.forEachFeatureAtPixel(pixel, function (feature) {\n        features.push(feature);\n      });\n      if (features.length > 0) {\n        const info = [];\n        let i, ii;\n        for (i = 0, ii = features.length; i < ii; ++i) {\n          info.push(features[i].get(\"desc\"));\n        }\n        document.getElementById(\"info\").innerHTML =\n          info.join(\", \") || \"(unknown)\";\n        map.getTarget().style.cursor = \"pointer\";\n      } else {\n        document.getElementById(\"info\").innerHTML = \"&nbsp;\";\n        map.getTarget().style.cursor = \"\";\n      }\n    };\n\n    map.on(\"pointermove\", function (evt) {\n      if (evt.dragging) {\n        return;\n      }\n      const pixel = map.getEventPixel(evt.originalEvent);\n      displayFeatureInfo(pixel);\n    });\n\n    map.on(\"click\", function (evt) {\n      displayFeatureInfo(evt.pixel);\n    });\n  });\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n  #map {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n  }\n</style>\n","import script from \"./index.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./index.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./index.vue?vue&type=style&index=0&id=2a3beab6&scoped=true&lang=css\"\n\nimport exportComponent from \"/home/runner/work/openlayers/openlayers/node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-2a3beab6\"]])\n\nexport default __exports__","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar isArray = require('../internals/is-array');\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Safari < 13 does not throw an error in this case\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {\n  // makes no sense without proper strict mode support\n  if (this !== undefined) return true;\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).length = 1;\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\nmodule.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {\n    throw new $TypeError('Cannot set read only .length');\n  } return O.length = length;\n} : function (O, length) {\n  return O.length = length;\n};\n","/**\n * @module ol/format/xsd\n */\nimport { getAllTextContent, getDocument } from '../xml.js';\nimport { padNumber } from '../string.js';\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n    var s = getAllTextContent(node, false);\n    return readBooleanString(s);\n}\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n    var m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n    if (m) {\n        return m[1] !== undefined || false;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n    var s = getAllTextContent(node, false);\n    var dateTime = Date.parse(s);\n    return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n    var s = getAllTextContent(node, false);\n    return readDecimalString(s);\n}\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n    // FIXME check spec\n    var m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n    if (m) {\n        return parseFloat(m[1]);\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n    var s = getAllTextContent(node, false);\n    return readNonNegativeIntegerString(s);\n}\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n    var m = /^\\s*(\\d+)\\s*$/.exec(string);\n    if (m) {\n        return parseInt(m[1], 10);\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n    return getAllTextContent(node, false).trim();\n}\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n    writeStringTextNode(node, bool ? '1' : '0');\n}\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n    node.appendChild(getDocument().createCDATASection(string));\n}\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n    var date = new Date(dateTime * 1000);\n    var string = date.getUTCFullYear() +\n        '-' +\n        padNumber(date.getUTCMonth() + 1, 2) +\n        '-' +\n        padNumber(date.getUTCDate(), 2) +\n        'T' +\n        padNumber(date.getUTCHours(), 2) +\n        ':' +\n        padNumber(date.getUTCMinutes(), 2) +\n        ':' +\n        padNumber(date.getUTCSeconds(), 2) +\n        'Z';\n    node.appendChild(getDocument().createTextNode(string));\n}\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n    var string = decimal.toPrecision();\n    node.appendChild(getDocument().createTextNode(string));\n}\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n    var string = nonNegativeInteger.toString();\n    node.appendChild(getDocument().createTextNode(string));\n}\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n    node.appendChild(getDocument().createTextNode(string));\n}\n//# sourceMappingURL=xsd.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {\n    var o, t;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n        o = offset;\n    }\n    else if (n === 2) {\n        o = offset;\n        t = fraction;\n    }\n    else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length_1 = 0;\n        var cumulativeLengths = [0];\n        for (var i = offset + stride; i < end; i += stride) {\n            var x2 = flatCoordinates[i];\n            var y2 = flatCoordinates[i + 1];\n            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            cumulativeLengths.push(length_1);\n            x1 = x2;\n            y1 = y2;\n        }\n        var target = fraction * length_1;\n        var index = binarySearch(cumulativeLengths, target);\n        if (index < 0) {\n            t =\n                (target - cumulativeLengths[-index - 2]) /\n                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n            o = offset + (-index - 2) * stride;\n        }\n        else {\n            o = offset + index * stride;\n        }\n    }\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var dest = opt_dest ? opt_dest : new Array(dimension);\n    for (var i = 0; i < dimension; ++i) {\n        dest[i] =\n            o === undefined\n                ? NaN\n                : t === undefined\n                    ? flatCoordinates[o + i]\n                    : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n        return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(offset, offset + stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(end - stride, end);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n        var mid = (lo + hi) >> 1;\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(0, stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        if (offset == end) {\n            continue;\n        }\n        if (m < flatCoordinates[offset + stride - 1]) {\n            return null;\n        }\n        else if (m <= flatCoordinates[end - 1]) {\n            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n        offset = end;\n    }\n    return null;\n}\n//# sourceMappingURL=interpolate.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiLineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM, } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /** @class */ (function (_super) {\n    __extends(MultiLineString, _super);\n    /**\n     * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n     *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n     *     combination with `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n     */\n    function MultiLineString(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (Array.isArray(coordinates[0])) {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        else if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            var layout = _this.getLayout();\n            var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n            var flatCoordinates = [];\n            var ends = [];\n            for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n                var lineString = lineStrings[i];\n                if (i === 0) {\n                    layout = lineString.getLayout();\n                }\n                extend(flatCoordinates, lineString.getFlatCoordinates());\n                ends.push(flatCoordinates.length);\n            }\n            _this.setFlatCoordinates(layout, flatCoordinates);\n            _this.ends_ = ends;\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linestring to the multilinestring.\n     * @param {LineString} lineString LineString.\n     * @api\n     */\n    MultiLineString.prototype.appendLineString = function (lineString) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = lineString.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiLineString} Clone.\n     * @api\n     */\n    MultiLineString.prototype.clone = function () {\n        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        multiLineString.applyProperties(this);\n        return multiLineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * `opt_interpolate` controls interpolation between consecutive LineStrings\n     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n     * will be linearly interpolated between the last coordinate of one LineString\n     * and the first coordinate of the next LineString.  If `opt_interpolate` is\n     * `false` then the function will return `null` for Ms falling between\n     * LineStrings.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {\n        if ((this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) ||\n            this.flatCoordinates.length === 0) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n    };\n    /**\n     * Return the coordinates of the multilinestring.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinates = function () {\n        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    MultiLineString.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * Return the linestring at the specified index.\n     * @param {number} index Index.\n     * @return {LineString} LineString.\n     * @api\n     */\n    MultiLineString.prototype.getLineString = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linestrings of this multilinestring.\n     * @return {Array<LineString>} LineStrings.\n     * @api\n     */\n    MultiLineString.prototype.getLineStrings = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var layout = this.layout;\n        /** @type {Array<LineString>} */\n        var lineStrings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n            lineStrings.push(lineString);\n            offset = end;\n        }\n        return lineStrings;\n    };\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n    MultiLineString.prototype.getFlatMidpoints = function () {\n        var midpoints = [];\n        var flatCoordinates = this.flatCoordinates;\n        var offset = 0;\n        var ends = this.ends_;\n        var stride = this.stride;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n            extend(midpoints, midpoint);\n            offset = end;\n        }\n        return midpoints;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiLineString} Simplified MultiLineString.\n     * @protected\n     */\n    MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiLineString.prototype.getType = function () {\n        return 'MultiLineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiLineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multilinestring.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {GeometryLayout} [opt_layout] Layout.\n     * @api\n     */\n    MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return MultiLineString;\n}(SimpleGeometry));\nexport default MultiLineString;\n//# sourceMappingURL=MultiLineString.js.map","export * from \"-!../../../../node_modules/.pnpm/mini-css-extract-plugin@0.9.0_webpack@4.47.0/node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../node_modules/.pnpm/css-loader@3.6.0_webpack@4.47.0/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/.pnpm/postcss-loader@3.0.0/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../node_modules/.pnpm/cache-loader@4.1.0_webpack@4.47.0/node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/index.js??ref--1-1!./index.vue?vue&type=style&index=0&id=2a3beab6&scoped=true&lang=css\"","'use strict';\nvar $ = require('../internals/export');\nvar toObject = require('../internals/to-object');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar setArrayLength = require('../internals/array-set-length');\nvar doesNotExceedSafeInteger = require('../internals/does-not-exceed-safe-integer');\nvar fails = require('../internals/fails');\n\nvar INCORRECT_TO_LENGTH = fails(function () {\n  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\n\n// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError\n// https://bugs.chromium.org/p/v8/issues/detail?id=12681\nvar properErrorOnNonWritableLength = function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).push();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n};\n\nvar FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n\n// `Array.prototype.push` method\n// https://tc39.es/ecma262/#sec-array.prototype.push\n$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  push: function push(item) {\n    var O = toObject(this);\n    var len = lengthOfArrayLike(O);\n    var argCount = arguments.length;\n    doesNotExceedSafeInteger(len + argCount);\n    for (var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      len++;\n    }\n    setArrayLength(O, len);\n    return len;\n  }\n});\n","/**\n * @module ol/format/Feature\n */\nimport Units from '../proj/Units.js';\nimport { abstract } from '../util.js';\nimport { assign } from '../obj.js';\nimport { equivalent as equivalentProjection, get as getProjection, transformExtent, } from '../proj.js';\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nvar FeatureFormat = /** @class */ (function () {\n    function FeatureFormat() {\n        /**\n         * @protected\n         * @type {import(\"../proj/Projection.js\").default|undefined}\n         */\n        this.dataProjection = undefined;\n        /**\n         * @protected\n         * @type {import(\"../proj/Projection.js\").default|undefined}\n         */\n        this.defaultFeatureProjection = undefined;\n        /**\n         * A list media types supported by the format in descending order of preference.\n         * @type {Array<string>}\n         */\n        this.supportedMediaTypes = null;\n    }\n    /**\n     * Adds the data projection to the read options.\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Options.\n     * @return {ReadOptions|undefined} Options.\n     * @protected\n     */\n    FeatureFormat.prototype.getReadOptions = function (source, opt_options) {\n        var options;\n        if (opt_options) {\n            var dataProjection = opt_options.dataProjection\n                ? getProjection(opt_options.dataProjection)\n                : this.readProjection(source);\n            if (opt_options.extent &&\n                dataProjection &&\n                dataProjection.getUnits() === Units.TILE_PIXELS) {\n                dataProjection = getProjection(dataProjection);\n                dataProjection.setWorldExtent(opt_options.extent);\n            }\n            options = {\n                dataProjection: dataProjection,\n                featureProjection: opt_options.featureProjection,\n            };\n        }\n        return this.adaptOptions(options);\n    };\n    /**\n     * Sets the `dataProjection` on the options, if no `dataProjection`\n     * is set.\n     * @param {WriteOptions|ReadOptions|undefined} options\n     *     Options.\n     * @protected\n     * @return {WriteOptions|ReadOptions|undefined}\n     *     Updated options.\n     */\n    FeatureFormat.prototype.adaptOptions = function (options) {\n        return assign({\n            dataProjection: this.dataProjection,\n            featureProjection: this.defaultFeatureProjection,\n        }, options);\n    };\n    /**\n     * @abstract\n     * @return {Type} The format type.\n     */\n    FeatureFormat.prototype.getType = function () {\n        return abstract();\n    };\n    /**\n     * Read a single feature from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Read options.\n     * @return {import(\"../Feature.js\").FeatureLike} Feature.\n     */\n    FeatureFormat.prototype.readFeature = function (source, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read all features from a source.\n     *\n     * @abstract\n     * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Read options.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     */\n    FeatureFormat.prototype.readFeatures = function (source, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read a single geometry from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Read options.\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    FeatureFormat.prototype.readGeometry = function (source, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read the projection from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n     */\n    FeatureFormat.prototype.readProjection = function (source) {\n        return abstract();\n    };\n    /**\n     * Encode a feature in this format.\n     *\n     * @abstract\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n    FeatureFormat.prototype.writeFeature = function (feature, opt_options) {\n        return abstract();\n    };\n    /**\n     * Encode an array of features in this format.\n     *\n     * @abstract\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n    FeatureFormat.prototype.writeFeatures = function (features, opt_options) {\n        return abstract();\n    };\n    /**\n     * Write a single geometry in this format.\n     *\n     * @abstract\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n    FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {\n        return abstract();\n    };\n    return FeatureFormat;\n}());\nexport default FeatureFormat;\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [opt_options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, opt_options) {\n    var featureProjection = opt_options\n        ? getProjection(opt_options.featureProjection)\n        : null;\n    var dataProjection = opt_options\n        ? getProjection(opt_options.dataProjection)\n        : null;\n    var transformed;\n    if (featureProjection &&\n        dataProjection &&\n        !equivalentProjection(featureProjection, dataProjection)) {\n        transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);\n    }\n    else {\n        transformed = geometry;\n    }\n    if (write &&\n        opt_options &&\n        /** @type {WriteOptions} */ (opt_options).decimals !== undefined) {\n        var power_1 = Math.pow(10, \n        /** @type {WriteOptions} */ (opt_options).decimals);\n        // if decimals option on write, round each coordinate appropriately\n        /**\n         * @param {Array<number>} coordinates Coordinates.\n         * @return {Array<number>} Transformed coordinates.\n         */\n        var transform = function (coordinates) {\n            for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n                coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;\n            }\n            return coordinates;\n        };\n        if (transformed === geometry) {\n            transformed = geometry.clone();\n        }\n        transformed.applyTransform(transform);\n    }\n    return transformed;\n}\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [opt_options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, opt_options) {\n    var featureProjection = opt_options\n        ? getProjection(opt_options.featureProjection)\n        : null;\n    var dataProjection = opt_options\n        ? getProjection(opt_options.dataProjection)\n        : null;\n    if (featureProjection &&\n        dataProjection &&\n        !equivalentProjection(featureProjection, dataProjection)) {\n        return transformExtent(extent, dataProjection, featureProjection);\n    }\n    else {\n        return extent;\n    }\n}\n//# sourceMappingURL=Feature.js.map","/**\n * @module ol/xml\n */\nimport { extend } from './array.js';\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n/**\n * @type {string}\n */\nexport var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n    return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n    return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n    if (node.nodeType == Node.CDATA_SECTION_NODE ||\n        node.nodeType == Node.TEXT_NODE) {\n        if (normalizeWhitespace) {\n            accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n        }\n        else {\n            accumulator.push(node.nodeValue);\n        }\n    }\n    else {\n        var n = void 0;\n        for (n = node.firstChild; n; n = n.nextSibling) {\n            getAllTextContent_(n, normalizeWhitespace, accumulator);\n        }\n    }\n    return accumulator;\n}\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n    return 'documentElement' in object;\n}\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n    return node.getAttributeNS(namespaceURI, name) || '';\n}\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n    return new DOMParser().parseFromString(xml, 'application/xml');\n}\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, opt_this) {\n    return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n            extend(array, value);\n        }\n    });\n}\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, opt_this) {\n    return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n            array.push(value);\n        }\n    });\n}\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, opt_this) {\n    return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            objectStack[objectStack.length - 1] = value;\n        }\n    });\n}\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n    return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n            var property = opt_property !== undefined ? opt_property : node.localName;\n            var array = void 0;\n            if (property in object) {\n                array = object[property];\n            }\n            else {\n                array = [];\n                object[property] = array;\n            }\n            array.push(value);\n        }\n    });\n}\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n    return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n        if (value !== undefined) {\n            var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n            var property = opt_property !== undefined ? opt_property : node.localName;\n            object[property] = value;\n        }\n    });\n}\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, opt_this) {\n    return function (node, value, objectStack) {\n        nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\n        var parent = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n        var parentNode = parent.node;\n        parentNode.appendChild(node);\n    };\n}\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, opt_this) {\n    var serializersNS, nodeFactory;\n    return function (node, value, objectStack) {\n        if (serializersNS === undefined) {\n            serializersNS = {};\n            var serializers = {};\n            serializers[node.localName] = nodeWriter;\n            serializersNS[node.namespaceURI] = serializers;\n            nodeFactory = makeSimpleNodeFactory(node.localName);\n        }\n        serialize(serializersNS, nodeFactory, value, objectStack);\n    };\n}\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [opt_nodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [opt_namespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n    var fixedNodeName = opt_nodeName;\n    return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [opt_nodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, opt_nodeName) {\n        var context = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n        var node = context.node;\n        var nodeName = fixedNodeName;\n        if (nodeName === undefined) {\n            nodeName = opt_nodeName;\n        }\n        var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n        return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    });\n}\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n    var length = orderedKeys.length;\n    var sequence = new Array(length);\n    for (var i = 0; i < length; ++i) {\n        sequence[i] = object[orderedKeys[i]];\n    }\n    return sequence;\n}\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [opt_structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n    /**\n     * @type {Object<string, T>}\n     */\n    var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n    var i, ii;\n    for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n        structureNS[namespaceURIs[i]] = structure;\n    }\n    return structureNS;\n}\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n    var n;\n    for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n        var parsers = parsersNS[n.namespaceURI];\n        if (parsers !== undefined) {\n            var parser = parsers[n.localName];\n            if (parser !== undefined) {\n                parser.call(opt_this, n, objectStack);\n            }\n        }\n    }\n}\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\n    objectStack.push(object);\n    parseNode(parsersNS, node, objectStack, opt_this);\n    return /** @type {T} */ (objectStack.pop());\n}\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n    var length = (opt_keys !== undefined ? opt_keys : values).length;\n    var value, node;\n    for (var i = 0; i < length; ++i) {\n        value = values[i];\n        if (value !== undefined) {\n            node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);\n            if (node !== undefined) {\n                serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);\n            }\n        }\n    }\n}\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n    objectStack.push(object);\n    serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n    return /** @type {O|undefined} */ (objectStack.pop());\n}\nvar xmlSerializer_ = undefined;\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n    xmlSerializer_ = xmlSerializer;\n}\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n    if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n        xmlSerializer_ = new XMLSerializer();\n    }\n    return xmlSerializer_;\n}\nvar document_ = undefined;\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n    document_ = document;\n}\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n    if (document_ === undefined && typeof document !== 'undefined') {\n        document_ = document.implementation.createDocument('', '', null);\n    }\n    return document_;\n}\n//# sourceMappingURL=xml.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { forEach as forEachSegment } from './flat/segments.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { interpolatePoint, lineStringCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineString } from './flat/intersectsextent.js';\nimport { lineStringLength } from './flat/length.js';\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /** @class */ (function (_super) {\n    __extends(LineString, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function LineString(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatMidpoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatMidpointRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed coordinate to the coordinates of the linestring.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @api\n     */\n    LineString.prototype.appendCoordinate = function (coordinate) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = coordinate.slice();\n        }\n        else {\n            extend(this.flatCoordinates, coordinate);\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LineString} Clone.\n     * @api\n     */\n    LineString.prototype.clone = function () {\n        var lineString = new LineString(this.flatCoordinates.slice(), this.layout);\n        lineString.applyProperties(this);\n        return lineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Iterate over each segment, calling the provided callback.\n     * If the callback returns a truthy value the function returns that\n     * value immediately. Otherwise the function returns `false`.\n     *\n     * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n     * @return {T|boolean} Value.\n     * @template T,S\n     * @api\n     */\n    LineString.prototype.forEachSegment = function (callback) {\n        return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {\n        if (this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n    };\n    /**\n     * Return the coordinates of the linestring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LineString.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinate at the provided fraction along the linestring.\n     * The `fraction` is a number between 0 and 1, where 0 is the start of the\n     * linestring and 1 is the end.\n     * @param {number} fraction Fraction.\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_dest] Optional coordinate whose values will\n     *     be modified. If not provided, a new coordinate will be returned.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n     * @api\n     */\n    LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {\n        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);\n    };\n    /**\n     * Return the length of the linestring on projected plane.\n     * @return {number} Length (on projected plane).\n     * @api\n     */\n    LineString.prototype.getLength = function () {\n        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat midpoint.\n     */\n    LineString.prototype.getFlatMidpoint = function () {\n        if (this.flatMidpointRevision_ != this.getRevision()) {\n            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n            this.flatMidpointRevision_ = this.getRevision();\n        }\n        return this.flatMidpoint_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} Simplified LineString.\n     * @protected\n     */\n    LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    LineString.prototype.getType = function () {\n        return 'LineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the linestring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    LineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LineString;\n}(SimpleGeometry));\nexport default LineString;\n//# sourceMappingURL=LineString.js.map"],"sourceRoot":""}