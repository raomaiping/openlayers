{"version":3,"sources":["webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/structs/LRUCache.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/tilegrid.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/tileurlfunction.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/layer/BaseTile.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/layer/TileProperty.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/tilecoord.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/TileCache.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/source/TileEventType.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/source/Tile.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/source/UrlTile.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/source/TileImage.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/TileRange.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/ImageTile.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/renderer/canvas/TileLayer.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/layer/Tile.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/Tile.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/reproj/Tile.js"],"names":["LRUCache","opt_highWaterMark","this","highWaterMark","undefined","count_","entries_","oldest_","newest_","prototype","canExpireCache","getCount","expireCache","keep","pop","clear","containsKey","key","hasOwnProperty","forEach","f","entry","value_","key_","newer","get","opt_options","older","remove","getKeys","keys","Array","i","getValues","values","peekLast","peekLastKey","peekFirstKey","peek","replace","value","set","setSize","size","getForProjection","projection","tileGrid","getDefaultTileGrid","opt_maxZoom","opt_tileSize","opt_corner","extent","extentFromProjection","corner","resolutions","resolutionsFromExtent","origin","tileSize","createForExtent","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createXYZ","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","maxResolution","opt_maxResolution","height","width","max","length","pow","half","DEGREES","getMetersPerUnit","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","pixelRatio","toString","range","getFullTileRange","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","expandUrl","url","urls","match","exec","startCharCode","charCodeAt","stopCharCode","charCode","push","String","fromCharCode","stop_1","parseInt","extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","p","call","TypeError","__","constructor","create","_super","BaseTileLayer","_this","options","baseOptions","preload","useInterimTilesOnError","on","once","un","setPreload","setUseInterimTilesOnError","getPreload","TileProperty","getUseInterimTilesOnError","getData","pixel","Layer","tmpTileCoord","TileGrid","zoomFactor","resolutions_","a","origins","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSizes","tileSize_","extent_","fullTileRanges_","tmpSize_","tmpExtent_","sizes","map","tileRange","min","restrictedTileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","calculateTileRanges_","forEachTileCoord","zoom","callback","j","jj","forEachTileCoordParentTileRange","opt_tileRange","opt_extent","x","y","tileCoordExtent","getTileCoordExtent","floor","getMaxZoom","getMinZoom","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","getTileRangeExtent","resolution","getTileSize","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","opt_tileCoord","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","getTileCoordResolution","opt_direction","tileCoordIntersectsViewport","viewport","fullTileRanges","createOrUpdate","getKeyZXY","getKey","fromKey","split","Number","hash","withinExtentAndZ","containsXY","TileCache","apply","arguments","usedTiles","release","pruneExceptNewestZ","tile","bind","TileSource","attributions","attributionsCollapsible","state","interpolate","opaque_","opaque","tilePixelRatio_","tilePixelRatio","tileCache","cacheSize","tmpSize","tileOptions","transition","zDirection","getTileCacheForProjection","forEachLoadedTile","tileCoordKey","loaded","covered","getState","TileState","LOADED","getGutterForProjection","setKey","changed","getOpaque","getTile","getTileGrid","getTileGridForProjection","sourceProjection","getProjection","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","opt_projection","getWrapX","isGlobal","refresh","updateCacheSize","tileCount","useTile","Source","TileSourceEvent","type","Event","UrlTile","generateTileUrlFunction_","tileUrlFunction","tileLoadFunction","setUrls","setUrl","tileLoadingKeys_","getTileLoadFunction","getTileUrlFunction","getPrototypeOf","getUrls","handleTileChange","event","uid","tileState","LOADING","TileEventType","ERROR","dispatchEvent","setTileLoadFunction","setTileUrlFunction","join","TileImage","imageSmoothing","defaultTileLoadFunction","crossOrigin","tileClass","ImageTile","tileCacheForProjection","tileGridForProjection","reprojectionErrorThreshold_","reprojectionErrorThreshold","renderReprojectionEdges_","usedTileCache","id","getGutter","getInterpolate","thisProj","projKey","createTile_","urlTileCoord","tileUrl","IDLE","EMPTY","addEventListener","EventType","CHANGE","cache","sourceTileGrid","targetTileGrid","wrappedTileCoord","newTile","getTileInternal","interimTile","refreshInterimChain","setRenderReprojectionEdges","render","setTileGridForProjection","tilegrid","proj","imageTile","src","getImage","TileRange","contains","containsTileRange","equals","extend","getSize","getWidth","intersects","crossOrigin_","src_","image_","Image","unlisten_","tileLoadFunction_","setImage","element","unlistenImage_","handleImageError_","ctx","fillStyle","fillRect","canvas","handleImageLoad_","image","naturalWidth","naturalHeight","load","CanvasTileLayerRenderer","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","getLayer","frameState","viewState","getSource","setState","getInterimTile","layer","pixelToCoordinateTransform","slice","layerExtent","source","getRenderSource","tileOrigin","tileResolution","col","row","gutter","round","getImageData","loadedTileCallback","tiles","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","viewCenter","rotation","tileSource","sourceRevision","getRevision","dx","dy","canvasExtent","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","inTransition","opacity","endTransition","indexOf","getAlpha","time","childTileRange","canvasScale","pixelTransform","canvasTransform","useContainer","getBackground","context","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","preRender","clips","clipZs","currentClip","zs","sort","reverse","currentZ","currentTilePixelSize","currentScale","dx_1","dy_1","originTileCoord","originTileExtent","origin_1","tileGutter","tilesToDraw","xIndex","nextX","yIndex","nextY","w","contextSaved","i_1","clip","save","beginPath","moveTo","lineTo","drawTileImage","restore","unshift","updateUsedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","getTileImage","alpha","alphaChanged","globalAlpha","drawImage","animate","postRenderFunction","tileSourceKey","postRenderFunctions","opt_tileCallback","wantedTiles","tileQueue","isKeyQueued","enqueue","TileLayer","createRenderer","BaseTile","Tile","transition_","transitionStarts_","prev","getTileCoord","Error","start","delta","ReprojTile","sourceProj","targetProj","getTileFunction","opt_errorThreshold","opt_renderEdges","opt_interpolate","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","sourceProjExtent","targetResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","srcX","srcY","reproject_","sources","arr","leftToLoad_1","sourceListenKey_1","e","unlistenSources_","setTimeout","getContext"],"mappings":"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","file":"js/chunk-af7294ae.9f4b6b13.js","sourcesContent":["/**\n * @module ol/structs/LRUCache\n */\nimport { assert } from '../asserts.js';\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nvar LRUCache = /** @class */ (function () {\n    /**\n     * @param {number} [opt_highWaterMark] High water mark.\n     */\n    function LRUCache(opt_highWaterMark) {\n        /**\n         * Desired max cache size after expireCache(). If set to 0, no cache entries\n         * will be pruned at all.\n         * @type {number}\n         */\n        this.highWaterMark =\n            opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.count_ = 0;\n        /**\n         * @private\n         * @type {!Object<string, Entry>}\n         */\n        this.entries_ = {};\n        /**\n         * @private\n         * @type {?Entry}\n         */\n        this.oldest_ = null;\n        /**\n         * @private\n         * @type {?Entry}\n         */\n        this.newest_ = null;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    LRUCache.prototype.canExpireCache = function () {\n        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n    };\n    /**\n     * Expire the cache.\n     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n     */\n    LRUCache.prototype.expireCache = function (keep) {\n        while (this.canExpireCache()) {\n            this.pop();\n        }\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n    LRUCache.prototype.clear = function () {\n        this.count_ = 0;\n        this.entries_ = {};\n        this.oldest_ = null;\n        this.newest_ = null;\n    };\n    /**\n     * @param {string} key Key.\n     * @return {boolean} Contains key.\n     */\n    LRUCache.prototype.containsKey = function (key) {\n        return this.entries_.hasOwnProperty(key);\n    };\n    /**\n     * @param {function(T, string, LRUCache<T>): ?} f The function\n     *     to call for every entry from the oldest to the newer. This function takes\n     *     3 arguments (the entry value, the entry key and the LRUCache object).\n     *     The return value is ignored.\n     */\n    LRUCache.prototype.forEach = function (f) {\n        var entry = this.oldest_;\n        while (entry) {\n            f(entry.value_, entry.key_, this);\n            entry = entry.newer;\n        }\n    };\n    /**\n     * @param {string} key Key.\n     * @param {*} [opt_options] Options (reserved for subclasses).\n     * @return {T} Value.\n     */\n    LRUCache.prototype.get = function (key, opt_options) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n        if (entry === this.newest_) {\n            return entry.value_;\n        }\n        else if (entry === this.oldest_) {\n            this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n            this.oldest_.older = null;\n        }\n        else {\n            entry.newer.older = entry.older;\n            entry.older.newer = entry.newer;\n        }\n        entry.newer = null;\n        entry.older = this.newest_;\n        this.newest_.newer = entry;\n        this.newest_ = entry;\n        return entry.value_;\n    };\n    /**\n     * Remove an entry from the cache.\n     * @param {string} key The entry key.\n     * @return {T} The removed entry.\n     */\n    LRUCache.prototype.remove = function (key) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n        if (entry === this.newest_) {\n            this.newest_ = /** @type {Entry} */ (entry.older);\n            if (this.newest_) {\n                this.newest_.newer = null;\n            }\n        }\n        else if (entry === this.oldest_) {\n            this.oldest_ = /** @type {Entry} */ (entry.newer);\n            if (this.oldest_) {\n                this.oldest_.older = null;\n            }\n        }\n        else {\n            entry.newer.older = entry.older;\n            entry.older.newer = entry.newer;\n        }\n        delete this.entries_[key];\n        --this.count_;\n        return entry.value_;\n    };\n    /**\n     * @return {number} Count.\n     */\n    LRUCache.prototype.getCount = function () {\n        return this.count_;\n    };\n    /**\n     * @return {Array<string>} Keys.\n     */\n    LRUCache.prototype.getKeys = function () {\n        var keys = new Array(this.count_);\n        var i = 0;\n        var entry;\n        for (entry = this.newest_; entry; entry = entry.older) {\n            keys[i++] = entry.key_;\n        }\n        return keys;\n    };\n    /**\n     * @return {Array<T>} Values.\n     */\n    LRUCache.prototype.getValues = function () {\n        var values = new Array(this.count_);\n        var i = 0;\n        var entry;\n        for (entry = this.newest_; entry; entry = entry.older) {\n            values[i++] = entry.value_;\n        }\n        return values;\n    };\n    /**\n     * @return {T} Last value.\n     */\n    LRUCache.prototype.peekLast = function () {\n        return this.oldest_.value_;\n    };\n    /**\n     * @return {string} Last key.\n     */\n    LRUCache.prototype.peekLastKey = function () {\n        return this.oldest_.key_;\n    };\n    /**\n     * Get the key of the newest item in the cache.  Throws if the cache is empty.\n     * @return {string} The newest key.\n     */\n    LRUCache.prototype.peekFirstKey = function () {\n        return this.newest_.key_;\n    };\n    /**\n     * Return an entry without updating least recently used time.\n     * @param {string} key Key.\n     * @return {T} Value.\n     */\n    LRUCache.prototype.peek = function (key) {\n        if (!this.containsKey(key)) {\n            return undefined;\n        }\n        return this.entries_[key].value_;\n    };\n    /**\n     * @return {T} value Value.\n     */\n    LRUCache.prototype.pop = function () {\n        var entry = this.oldest_;\n        delete this.entries_[entry.key_];\n        if (entry.newer) {\n            entry.newer.older = null;\n        }\n        this.oldest_ = /** @type {Entry} */ (entry.newer);\n        if (!this.oldest_) {\n            this.newest_ = null;\n        }\n        --this.count_;\n        return entry.value_;\n    };\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n    LRUCache.prototype.replace = function (key, value) {\n        this.get(key); // update `newest_`\n        this.entries_[key].value_ = value;\n    };\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n    LRUCache.prototype.set = function (key, value) {\n        assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n        var entry = {\n            key_: key,\n            newer: null,\n            older: this.newest_,\n            value_: value,\n        };\n        if (!this.newest_) {\n            this.oldest_ = entry;\n        }\n        else {\n            this.newest_.newer = entry;\n        }\n        this.newest_ = entry;\n        this.entries_[key] = entry;\n        ++this.count_;\n    };\n    /**\n     * Set a maximum number of entries for the cache.\n     * @param {number} size Cache size.\n     * @api\n     */\n    LRUCache.prototype.setSize = function (size) {\n        this.highWaterMark = size;\n    };\n    return LRUCache;\n}());\nexport default LRUCache;\n//# sourceMappingURL=LRUCache.js.map","/**\n * @module ol/tilegrid\n */\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, get as getProjection } from './proj.js';\nimport { containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth, } from './extent.js';\nimport { toSize } from './size.js';\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n    var tileGrid = projection.getDefaultTileGrid();\n    if (!tileGrid) {\n        tileGrid = createForProjection(projection);\n        projection.setDefaultTileGrid(tileGrid);\n    }\n    return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n    var z = tileCoord[0];\n    var center = tileGrid.getTileCoordCenter(tileCoord);\n    var projectionExtent = extentFromProjection(projection);\n    if (!containsCoordinate(projectionExtent, center)) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n        center[0] += worldWidth * worldsAway;\n        return tileGrid.getTileCoordForCoordAndZ(center, z);\n    }\n    else {\n        return tileCoord;\n    }\n}\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n    var corner = opt_corner !== undefined ? opt_corner : 'top-left';\n    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n    return new TileGrid({\n        extent: extent,\n        origin: getCorner(extent, corner),\n        resolutions: resolutions,\n        tileSize: opt_tileSize,\n    });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [opt_options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n    var xyzOptions = opt_options || {};\n    var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n    var gridOptions = {\n        extent: extent,\n        minZoom: xyzOptions.minZoom,\n        tileSize: xyzOptions.tileSize,\n        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),\n    };\n    return new TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [opt_maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n    var height = getHeight(extent);\n    var width = getWidth(extent);\n    var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n    var maxResolution = opt_maxResolution > 0\n        ? opt_maxResolution\n        : Math.max(width / tileSize[0], height / tileSize[1]);\n    var length = maxZoom + 1;\n    var resolutions = new Array(length);\n    for (var z = 0; z < length; ++z) {\n        resolutions[z] = maxResolution / Math.pow(2, z);\n    }\n    return resolutions;\n}\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n    var extent = extentFromProjection(projection);\n    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n    projection = getProjection(projection);\n    var extent = projection.getExtent();\n    if (!extent) {\n        var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n        extent = createOrUpdate(-half, -half, half, half);\n    }\n    return extent;\n}\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/tileurlfunction\n */\nimport { assert } from './asserts.js';\nimport { modulo } from './math.js';\nimport { hash as tileCoordHash } from './tilecoord.js';\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n    var zRegEx = /\\{z\\}/g;\n    var xRegEx = /\\{x\\}/g;\n    var yRegEx = /\\{y\\}/g;\n    var dashYRegEx = /\\{-y\\}/g;\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            return template\n                .replace(zRegEx, tileCoord[0].toString())\n                .replace(xRegEx, tileCoord[1].toString())\n                .replace(yRegEx, tileCoord[2].toString())\n                .replace(dashYRegEx, function () {\n                var z = tileCoord[0];\n                var range = tileGrid.getFullTileRange(z);\n                assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n                var y = range.getHeight() - tileCoord[2] - 1;\n                return y.toString();\n            });\n        }\n    });\n}\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n    var len = templates.length;\n    var tileUrlFunctions = new Array(len);\n    for (var i = 0; i < len; ++i) {\n        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n    }\n    return createFromTileUrlFunctions(tileUrlFunctions);\n}\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n    if (tileUrlFunctions.length === 1) {\n        return tileUrlFunctions[0];\n    }\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            var h = tileCoordHash(tileCoord);\n            var index = modulo(h, tileUrlFunctions.length);\n            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n        }\n    });\n}\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n}\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n    var urls = [];\n    var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n    if (match) {\n        // char range\n        var startCharCode = match[1].charCodeAt(0);\n        var stopCharCode = match[2].charCodeAt(0);\n        var charCode = void 0;\n        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n            urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n        }\n        return urls;\n    }\n    match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n    if (match) {\n        // number range\n        var stop_1 = parseInt(match[2], 10);\n        for (var i = parseInt(match[1], 10); i <= stop_1; i++) {\n            urls.push(url.replace(match[0], i.toString()));\n        }\n        return urls;\n    }\n    urls.push(url);\n    return urls;\n}\n//# sourceMappingURL=tileurlfunction.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\nimport { assign } from '../obj.js';\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../PluggableMap.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nvar BaseTileLayer = /** @class */ (function (_super) {\n    __extends(BaseTileLayer, _super);\n    /**\n     * @param {Options<TileSourceType>} [opt_options] Tile layer options.\n     */\n    function BaseTileLayer(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var baseOptions = assign({}, options);\n        delete baseOptions.preload;\n        delete baseOptions.useInterimTilesOnError;\n        _this = _super.call(this, baseOptions) || this;\n        /***\n         * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {BaseTileLayerOnSignature<void>}\n         */\n        _this.un;\n        _this.setPreload(options.preload !== undefined ? options.preload : 0);\n        _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined\n            ? options.useInterimTilesOnError\n            : true);\n        return _this;\n    }\n    /**\n     * Return the level as number to which we will preload tiles up to.\n     * @return {number} The level to preload tiles up to.\n     * @observable\n     * @api\n     */\n    BaseTileLayer.prototype.getPreload = function () {\n        return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n    };\n    /**\n     * Set the level as number to which we will preload tiles up to.\n     * @param {number} preload The level to preload tiles up to.\n     * @observable\n     * @api\n     */\n    BaseTileLayer.prototype.setPreload = function (preload) {\n        this.set(TileProperty.PRELOAD, preload);\n    };\n    /**\n     * Whether we use interim tiles on error.\n     * @return {boolean} Use interim tiles on error.\n     * @observable\n     * @api\n     */\n    BaseTileLayer.prototype.getUseInterimTilesOnError = function () {\n        return /** @type {boolean} */ (this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR));\n    };\n    /**\n     * Set whether we use interim tiles on error.\n     * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n     * @observable\n     * @api\n     */\n    BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {\n        this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n    };\n    /**\n     * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n     * a four element RGBA array will be returned.  For data tiles, the array length will match the\n     * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n     * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n     *\n     * ```js\n     * // display layer data on every pointer move\n     * map.on('pointermove', (event) => {\n     *   console.log(layer.getData(event.pixel));\n     * });\n     * ```\n     * @param {import(\"../pixel\").Pixel} pixel Pixel.\n     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n     * @api\n     */\n    BaseTileLayer.prototype.getData = function (pixel) {\n        return _super.prototype.getData.call(this, pixel);\n    };\n    return BaseTileLayer;\n}(Layer));\nexport default BaseTileLayer;\n//# sourceMappingURL=BaseTile.js.map","/**\n * @module ol/layer/TileProperty\n */\n/**\n * @enum {string}\n */\nexport default {\n    PRELOAD: 'preload',\n    USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n//# sourceMappingURL=TileProperty.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange, } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { ceil, clamp, floor } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { intersectsLinearRing } from '../geom/flat/intersectsextent.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nvar DECIMALS = 5;\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = /** @class */ (function () {\n    /**\n     * @param {Options} options Tile grid options.\n     */\n    function TileGrid(options) {\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n        /**\n         * @private\n         * @type {!Array<number>}\n         */\n        this.resolutions_ = options.resolutions;\n        assert(isSorted(this.resolutions_, function (a, b) {\n            return b - a;\n        }, true), 17); // `resolutions` must be sorted in descending order\n        // check if we've got a consistent zoom factor and origin\n        var zoomFactor;\n        if (!options.origins) {\n            for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n                if (!zoomFactor) {\n                    zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n                }\n                else {\n                    if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n                        zoomFactor = undefined;\n                        break;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.zoomFactor_ = zoomFactor;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.maxZoom = this.resolutions_.length - 1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate|null}\n         */\n        this.origin_ = options.origin !== undefined ? options.origin : null;\n        /**\n         * @private\n         * @type {Array<import(\"../coordinate.js\").Coordinate>}\n         */\n        this.origins_ = null;\n        if (options.origins !== undefined) {\n            this.origins_ = options.origins;\n            assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n        }\n        var extent = options.extent;\n        if (extent !== undefined && !this.origin_ && !this.origins_) {\n            this.origin_ = getTopLeft(extent);\n        }\n        assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both\n        /**\n         * @private\n         * @type {Array<number|import(\"../size.js\").Size>}\n         */\n        this.tileSizes_ = null;\n        if (options.tileSizes !== undefined) {\n            this.tileSizes_ = options.tileSizes;\n            assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n        }\n        /**\n         * @private\n         * @type {number|import(\"../size.js\").Size}\n         */\n        this.tileSize_ =\n            options.tileSize !== undefined\n                ? options.tileSize\n                : !this.tileSizes_\n                    ? DEFAULT_TILE_SIZE\n                    : null;\n        assert((!this.tileSize_ && this.tileSizes_) ||\n            (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.extent_ = extent !== undefined ? extent : null;\n        /**\n         * @private\n         * @type {Array<import(\"../TileRange.js\").default>}\n         */\n        this.fullTileRanges_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n        this.tmpSize_ = [0, 0];\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.tmpExtent_ = [0, 0, 0, 0];\n        if (options.sizes !== undefined) {\n            this.fullTileRanges_ = options.sizes.map(function (size, z) {\n                var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n                if (extent) {\n                    var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n                    tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n                    tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n                    tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n                    tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n                }\n                return tileRange;\n            }, this);\n        }\n        else if (extent) {\n            this.calculateTileRanges_(extent);\n        }\n    }\n    /**\n     * Call a function with each tile coordinate for a given extent and zoom level.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} zoom Integer zoom level.\n     * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {\n        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n            for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n                callback([zoom, i, j]);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {boolean} Callback succeeded.\n     */\n    TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {\n        var tileRange, x, y;\n        var tileCoordExtent = null;\n        var z = tileCoord[0] - 1;\n        if (this.zoomFactor_ === 2) {\n            x = tileCoord[1];\n            y = tileCoord[2];\n        }\n        else {\n            tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n        }\n        while (z >= this.minZoom) {\n            if (this.zoomFactor_ === 2) {\n                x = Math.floor(x / 2);\n                y = Math.floor(y / 2);\n                tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n            }\n            else {\n                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n            }\n            if (callback(z, tileRange)) {\n                return true;\n            }\n            --z;\n        }\n        return false;\n    };\n    /**\n     * Get the extent for this tile grid, if it was configured.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getExtent = function () {\n        return this.extent_;\n    };\n    /**\n     * Get the maximum zoom level for the grid.\n     * @return {number} Max zoom.\n     * @api\n     */\n    TileGrid.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    /**\n     * Get the minimum zoom level for the grid.\n     * @return {number} Min zoom.\n     * @api\n     */\n    TileGrid.prototype.getMinZoom = function () {\n        return this.minZoom;\n    };\n    /**\n     * Get the origin for the grid at the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {import(\"../coordinate.js\").Coordinate} Origin.\n     * @api\n     */\n    TileGrid.prototype.getOrigin = function (z) {\n        if (this.origin_) {\n            return this.origin_;\n        }\n        else {\n            return this.origins_[z];\n        }\n    };\n    /**\n     * Get the resolution for the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {number} Resolution.\n     * @api\n     */\n    TileGrid.prototype.getResolution = function (z) {\n        return this.resolutions_[z];\n    };\n    /**\n     * Get the list of resolutions for the tile grid.\n     * @return {Array<number>} Resolutions.\n     * @api\n     */\n    TileGrid.prototype.getResolutions = function () {\n        return this.resolutions_;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../TileRange.js\").default|null} Tile range.\n     */\n    TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n        if (tileCoord[0] < this.maxZoom) {\n            if (this.zoomFactor_ === 2) {\n                var minX = tileCoord[1] * 2;\n                var minY = tileCoord[2] * 2;\n                return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n            }\n            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);\n            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n        }\n        return null;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @return {import(\"../TileRange.js\").default|null} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForTileCoordAndZ = function (tileCoord, z, opt_tileRange) {\n        if (z > this.maxZoom || z < this.minZoom) {\n            return null;\n        }\n        var tileCoordZ = tileCoord[0];\n        var tileCoordX = tileCoord[1];\n        var tileCoordY = tileCoord[2];\n        if (z === tileCoordZ) {\n            return createOrUpdateTileRange(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);\n        }\n        if (this.zoomFactor_) {\n            var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n            var minX = Math.floor(tileCoordX * factor);\n            var minY = Math.floor(tileCoordY * factor);\n            if (z < tileCoordZ) {\n                return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\n            }\n            var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n            var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n            return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\n        }\n        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    };\n    /**\n     * Get the extent for a tile range.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n    TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get a tile range for the given extent and integer zoom level.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n        var tileCoord = tmpTileCoord;\n        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n        var minX = tileCoord[1];\n        var minY = tileCoord[2];\n        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n        return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n     */\n    TileGrid.prototype.getTileCoordCenter = function (tileCoord) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        return [\n            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n        ];\n    };\n    /**\n     * Get the extent of a tile coordinate.\n     *\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n        var maxX = minX + tileSize[0] * resolution;\n        var maxY = minY + tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get the tile coordinate for the given map coordinate and resolution.  This\n     * method considers that coordinates that intersect tile boundaries should be\n     * assigned the higher tile coordinate.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n    };\n    /**\n     * Note that this method should not be called for resolutions that correspond\n     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} resolution Resolution (for a non-integer zoom level).\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n        var z = this.getZForResolution(resolution);\n        var scale = resolution / this.getResolution(z);\n        var origin = this.getOrigin(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n        var tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n     * they should have separate implementations.  This method is for integer zoom\n     * levels.  The other method should only be called for resolutions corresponding\n     * to non-integer zoom levels.\n     * @param {number} x Map x coordinate.\n     * @param {number} y Map y coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n        var tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Get a tile coordinate given a map coordinate and zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} z Zoom level.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {number} Tile resolution.\n     */\n    TileGrid.prototype.getTileCoordResolution = function (tileCoord) {\n        return this.resolutions_[tileCoord[0]];\n    };\n    /**\n     * Get the tile size for a zoom level. The type of the return value matches the\n     * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n     * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n     * @param {number} z Z.\n     * @return {number|import(\"../size.js\").Size} Tile size.\n     * @api\n     */\n    TileGrid.prototype.getTileSize = function (z) {\n        if (this.tileSize_) {\n            return this.tileSize_;\n        }\n        else {\n            return this.tileSizes_[z];\n        }\n    };\n    /**\n     * @param {number} z Zoom level.\n     * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n     */\n    TileGrid.prototype.getFullTileRange = function (z) {\n        if (!this.fullTileRanges_) {\n            return this.extent_\n                ? this.getTileRangeForExtentAndZ(this.extent_, z)\n                : null;\n        }\n        else {\n            return this.fullTileRanges_[z];\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n     *     If 0, the nearest resolution will be used.\n     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n     *     nearest lower resolution (higher Z) will be used. Default is 0.\n     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n     *\n     * For example to change tile Z at the midpoint of zoom levels\n     * ```js\n     * function(value, high, low) {\n     *   return value - low * Math.sqrt(high / low);\n     * }\n     * ```\n     * @return {number} Z.\n     * @api\n     */\n    TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\n        var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n        return clamp(z, this.minZoom, this.maxZoom);\n    };\n    /**\n     * The tile with the provided tile coordinate intersects the given viewport.\n     * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\n     * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n     * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n     */\n    TileGrid.prototype.tileCoordIntersectsViewport = function (tileCoord, viewport) {\n        return intersectsLinearRing(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));\n    };\n    /**\n     * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n     * @private\n     */\n    TileGrid.prototype.calculateTileRanges_ = function (extent) {\n        var length = this.resolutions_.length;\n        var fullTileRanges = new Array(length);\n        for (var z = this.minZoom; z < length; ++z) {\n            fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n        }\n        this.fullTileRanges_ = fullTileRanges;\n    };\n    return TileGrid;\n}());\nexport default TileGrid;\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/tilecoord\n */\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n    if (opt_tileCoord !== undefined) {\n        opt_tileCoord[0] = z;\n        opt_tileCoord[1] = x;\n        opt_tileCoord[2] = y;\n        return opt_tileCoord;\n    }\n    else {\n        return [z, x, y];\n    }\n}\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n    return z + '/' + x + '/' + y;\n}\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n    var _a = tileKey\n        .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n        .split(',')\n        .map(Number), z = _a[0], x = _a[1], y = _a[2];\n    return getKeyZXY(z, x, y);\n}\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n    return key.split('/').map(Number);\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n    var z = tileCoord[0];\n    var x = tileCoord[1];\n    var y = tileCoord[2];\n    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n        return false;\n    }\n    var tileRange = tileGrid.getFullTileRange(z);\n    if (!tileRange) {\n        return true;\n    }\n    else {\n        return tileRange.containsXY(x, y);\n    }\n}\n//# sourceMappingURL=tilecoord.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\nvar TileCache = /** @class */ (function (_super) {\n    __extends(TileCache, _super);\n    function TileCache() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    TileCache.prototype.expireCache = function (usedTiles) {\n        while (this.canExpireCache()) {\n            var tile = this.peekLast();\n            if (tile.getKey() in usedTiles) {\n                break;\n            }\n            else {\n                this.pop().release();\n            }\n        }\n    };\n    /**\n     * Prune all tiles from the cache that don't have the same z as the newest tile.\n     */\n    TileCache.prototype.pruneExceptNewestZ = function () {\n        if (this.getCount() === 0) {\n            return;\n        }\n        var key = this.peekFirstKey();\n        var tileCoord = fromKey(key);\n        var z = tileCoord[0];\n        this.forEach(function (tile) {\n            if (tile.tileCoord[0] !== z) {\n                this.remove(getKey(tile.tileCoord));\n                tile.release();\n            }\n        }.bind(this));\n    };\n    return TileCache;\n}(LRUCache));\nexport default TileCache;\n//# sourceMappingURL=TileCache.js.map","/**\n * @module ol/source/TileEventType\n */\n/**\n * @enum {string}\n */\nexport default {\n    /**\n     * Triggered when a tile starts loading.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n     * @api\n     */\n    TILELOADSTART: 'tileloadstart',\n    /**\n     * Triggered when a tile finishes loading, either when its data is loaded,\n     * or when loading was aborted because the tile is no longer needed.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n     * @api\n     */\n    TILELOADEND: 'tileloadend',\n    /**\n     * Triggered if tile loading results in an error.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n     * @api\n     */\n    TILELOADERROR: 'tileloaderror',\n};\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n//# sourceMappingURL=TileEventType.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport { abstract } from '../util.js';\nimport { assert } from '../asserts.js';\nimport { equivalent } from '../proj.js';\nimport { getKeyZXY, withinExtentAndZ } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection, wrapX, } from '../tilegrid.js';\nimport { scale as scaleSize, toSize } from '../size.js';\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nvar TileSource = /** @class */ (function (_super) {\n    __extends(TileSource, _super);\n    /**\n     * @param {Options} options SourceTile source options.\n     */\n    function TileSource(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            projection: options.projection,\n            state: options.state,\n            wrapX: options.wrapX,\n            interpolate: options.interpolate,\n        }) || this;\n        /***\n         * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {TileSourceOnSignature<void>}\n         */\n        _this.un;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.tilePixelRatio_ =\n            options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n        /**\n         * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n         */\n        _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n        var tileSize = [256, 256];\n        if (_this.tileGrid) {\n            toSize(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);\n        }\n        /**\n         * @protected\n         * @type {import(\"../TileCache.js\").default}\n         */\n        _this.tileCache = new TileCache(options.cacheSize || 0);\n        /**\n         * @protected\n         * @type {import(\"../size.js\").Size}\n         */\n        _this.tmpSize = [0, 0];\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.key_ = options.key || '';\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").Options}\n         */\n        _this.tileOptions = {\n            transition: options.transition,\n            interpolate: options.interpolate,\n        };\n        /**\n         * zDirection hint, read by the renderer. Indicates which resolution should be used\n         * by a renderer if the views resolution does not match any resolution of the tile source.\n         * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n         * will be used. If -1, the nearest higher resolution will be used.\n         * @type {number|import(\"../array.js\").NearestDirectionFunction}\n         */\n        _this.zDirection = options.zDirection ? options.zDirection : 0;\n        return _this;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    TileSource.prototype.canExpireCache = function () {\n        return this.tileCache.canExpireCache();\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    TileSource.prototype.expireCache = function (projection, usedTiles) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (tileCache) {\n            tileCache.expireCache(usedTiles);\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {number} z Zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n     *     loaded tile.  If the callback returns `false`, the tile will not be\n     *     considered loaded.\n     * @return {boolean} The tile range is fully covered with loaded tiles.\n     */\n    TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (!tileCache) {\n            return false;\n        }\n        var covered = true;\n        var tile, tileCoordKey, loaded;\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                tileCoordKey = getKeyZXY(z, x, y);\n                loaded = false;\n                if (tileCache.containsKey(tileCoordKey)) {\n                    tile = /** @type {!import(\"../Tile.js\").default} */ (tileCache.get(tileCoordKey));\n                    loaded = tile.getState() === TileState.LOADED;\n                    if (loaded) {\n                        loaded = callback(tile) !== false;\n                    }\n                }\n                if (!loaded) {\n                    covered = false;\n                }\n            }\n        }\n        return covered;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {number} Gutter.\n     */\n    TileSource.prototype.getGutterForProjection = function (projection) {\n        return 0;\n    };\n    /**\n     * Return the key to be used for all tiles in the source.\n     * @return {string} The key for all tiles.\n     */\n    TileSource.prototype.getKey = function () {\n        return this.key_;\n    };\n    /**\n     * Set the value to be used as the key for all tiles in the source.\n     * @param {string} key The key for tiles.\n     * @protected\n     */\n    TileSource.prototype.setKey = function (key) {\n        if (this.key_ !== key) {\n            this.key_ = key;\n            this.changed();\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {boolean} Opaque.\n     */\n    TileSource.prototype.getOpaque = function (projection) {\n        return this.opaque_;\n    };\n    /**\n     * @return {Array<number>|null} Resolutions.\n     */\n    TileSource.prototype.getResolutions = function () {\n        if (!this.tileGrid) {\n            return null;\n        }\n        return this.tileGrid.getResolutions();\n    };\n    /**\n     * @abstract\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../Tile.js\").default} Tile.\n     */\n    TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        return abstract();\n    };\n    /**\n     * Return the tile grid of the tile source.\n     * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n     * @api\n     */\n    TileSource.prototype.getTileGrid = function () {\n        return this.tileGrid;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    TileSource.prototype.getTileGridForProjection = function (projection) {\n        if (!this.tileGrid) {\n            return getTileGridForProjection(projection);\n        }\n        else {\n            return this.tileGrid;\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../TileCache.js\").default} Tile cache.\n     * @protected\n     */\n    TileSource.prototype.getTileCacheForProjection = function (projection) {\n        var sourceProjection = this.getProjection();\n        assert(sourceProjection === null || equivalent(sourceProjection, projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n        );\n        return this.tileCache;\n    };\n    /**\n     * Get the tile pixel ratio for this source. Subclasses may override this\n     * method, which is meant to return a supported pixel ratio that matches the\n     * provided `pixelRatio` as close as possible.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n    TileSource.prototype.getTilePixelRatio = function (pixelRatio) {\n        return this.tilePixelRatio_;\n    };\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n    TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n        if (tilePixelRatio == 1) {\n            return tileSize;\n        }\n        else {\n            return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n        }\n    };\n    /**\n     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n     * is outside the resolution and extent range of the tile grid, `null` will be\n     * returned.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../proj/Projection.js\").default} [opt_projection] Projection.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n     *     null if no tile URL should be created for the passed `tileCoord`.\n     */\n    TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {\n        var projection = opt_projection !== undefined ? opt_projection : this.getProjection();\n        var tileGrid = this.getTileGridForProjection(projection);\n        if (this.getWrapX() && projection.isGlobal()) {\n            tileCoord = wrapX(tileGrid, tileCoord, projection);\n        }\n        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n    };\n    /**\n     * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n     * @api\n     */\n    TileSource.prototype.clear = function () {\n        this.tileCache.clear();\n    };\n    TileSource.prototype.refresh = function () {\n        this.clear();\n        _super.prototype.refresh.call(this);\n    };\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    TileSource.prototype.updateCacheSize = function (tileCount, projection) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (tileCount > tileCache.highWaterMark) {\n            tileCache.highWaterMark = tileCount;\n        }\n    };\n    /**\n     * Marks a tile coord as being used, without triggering a load.\n     * @abstract\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    TileSource.prototype.useTile = function (z, x, y, projection) { };\n    return TileSource;\n}(Source));\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nvar TileSourceEvent = /** @class */ (function (_super) {\n    __extends(TileSourceEvent, _super);\n    /**\n     * @param {string} type Type.\n     * @param {import(\"../Tile.js\").default} tile The tile.\n     */\n    function TileSourceEvent(type, tile) {\n        var _this = _super.call(this, type) || this;\n        /**\n         * The tile related to the event.\n         * @type {import(\"../Tile.js\").default}\n         * @api\n         */\n        _this.tile = tile;\n        return _this;\n    }\n    return TileSourceEvent;\n}(Event));\nexport { TileSourceEvent };\nexport default TileSource;\n//# sourceMappingURL=Tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { createFromTemplates, expandUrl } from '../tileurlfunction.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Cache size.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] TileUrlFunction.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nvar UrlTile = /** @class */ (function (_super) {\n    __extends(UrlTile, _super);\n    /**\n     * @param {Options} options Image tile options.\n     */\n    function UrlTile(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            cacheSize: options.cacheSize,\n            opaque: options.opaque,\n            projection: options.projection,\n            state: options.state,\n            tileGrid: options.tileGrid,\n            tilePixelRatio: options.tilePixelRatio,\n            wrapX: options.wrapX,\n            transition: options.transition,\n            interpolate: options.interpolate,\n            key: options.key,\n            attributionsCollapsible: options.attributionsCollapsible,\n            zDirection: options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.generateTileUrlFunction_ =\n            _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").LoadFunction}\n         */\n        _this.tileLoadFunction = options.tileLoadFunction;\n        if (options.tileUrlFunction) {\n            _this.tileUrlFunction = options.tileUrlFunction;\n        }\n        /**\n         * @protected\n         * @type {!Array<string>|null}\n         */\n        _this.urls = null;\n        if (options.urls) {\n            _this.setUrls(options.urls);\n        }\n        else if (options.url) {\n            _this.setUrl(options.url);\n        }\n        /**\n         * @private\n         * @type {!Object<string, boolean>}\n         */\n        _this.tileLoadingKeys_ = {};\n        return _this;\n    }\n    /**\n     * Return the tile load function of the source.\n     * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n     * @api\n     */\n    UrlTile.prototype.getTileLoadFunction = function () {\n        return this.tileLoadFunction;\n    };\n    /**\n     * Return the tile URL function of the source.\n     * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n     * @api\n     */\n    UrlTile.prototype.getTileUrlFunction = function () {\n        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n            ? this.tileUrlFunction.bind(this)\n            : this.tileUrlFunction;\n    };\n    /**\n     * Return the URLs used for this source.\n     * When a tileUrlFunction is used instead of url or urls,\n     * null will be returned.\n     * @return {!Array<string>|null} URLs.\n     * @api\n     */\n    UrlTile.prototype.getUrls = function () {\n        return this.urls;\n    };\n    /**\n     * Handle tile change events.\n     * @param {import(\"../events/Event.js\").default} event Event.\n     * @protected\n     */\n    UrlTile.prototype.handleTileChange = function (event) {\n        var tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n        var uid = getUid(tile);\n        var tileState = tile.getState();\n        var type;\n        if (tileState == TileState.LOADING) {\n            this.tileLoadingKeys_[uid] = true;\n            type = TileEventType.TILELOADSTART;\n        }\n        else if (uid in this.tileLoadingKeys_) {\n            delete this.tileLoadingKeys_[uid];\n            type =\n                tileState == TileState.ERROR\n                    ? TileEventType.TILELOADERROR\n                    : tileState == TileState.LOADED\n                        ? TileEventType.TILELOADEND\n                        : undefined;\n        }\n        if (type != undefined) {\n            this.dispatchEvent(new TileSourceEvent(type, tile));\n        }\n    };\n    /**\n     * Set the tile load function of the source.\n     * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n     * @api\n     */\n    UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {\n        this.tileCache.clear();\n        this.tileLoadFunction = tileLoadFunction;\n        this.changed();\n    };\n    /**\n     * Set the tile URL function of the source.\n     * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n     * @param {string} [key] Optional new tile key for the source.\n     * @api\n     */\n    UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {\n        this.tileUrlFunction = tileUrlFunction;\n        this.tileCache.pruneExceptNewestZ();\n        if (typeof key !== 'undefined') {\n            this.setKey(key);\n        }\n        else {\n            this.changed();\n        }\n    };\n    /**\n     * Set the URL to use for requests.\n     * @param {string} url URL.\n     * @api\n     */\n    UrlTile.prototype.setUrl = function (url) {\n        var urls = expandUrl(url);\n        this.urls = urls;\n        this.setUrls(urls);\n    };\n    /**\n     * Set the URLs to use for requests.\n     * @param {Array<string>} urls URLs.\n     * @api\n     */\n    UrlTile.prototype.setUrls = function (urls) {\n        this.urls = urls;\n        var key = urls.join('\\n');\n        if (this.generateTileUrlFunction_) {\n            this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n        }\n        else {\n            this.setKey(key);\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {\n        return undefined;\n    };\n    /**\n     * Marks a tile coord as being used, without triggering a load.\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     */\n    UrlTile.prototype.useTile = function (z, x, y) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            this.tileCache.get(tileCoordKey);\n        }\n    };\n    return UrlTile;\n}(TileSource));\nexport default UrlTile;\n//# sourceMappingURL=UrlTile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/TileImage\n */\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport { ENABLE_RASTER_REPROJECTION } from '../reproj/common.js';\nimport { equivalent, get as getProjection } from '../proj.js';\nimport { getKey, getKeyZXY } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection } from '../tilegrid.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar TileImage = /** @class */ (function (_super) {\n    __extends(TileImage, _super);\n    /**\n     * @param {!Options} options Image tile options.\n     */\n    function TileImage(options) {\n        var _this = this;\n        var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;\n        if (options.interpolate !== undefined) {\n            interpolate = options.interpolate;\n        }\n        _this = _super.call(this, {\n            attributions: options.attributions,\n            cacheSize: options.cacheSize,\n            opaque: options.opaque,\n            projection: options.projection,\n            state: options.state,\n            tileGrid: options.tileGrid,\n            tileLoadFunction: options.tileLoadFunction\n                ? options.tileLoadFunction\n                : defaultTileLoadFunction,\n            tilePixelRatio: options.tilePixelRatio,\n            tileUrlFunction: options.tileUrlFunction,\n            url: options.url,\n            urls: options.urls,\n            wrapX: options.wrapX,\n            transition: options.transition,\n            interpolate: interpolate,\n            key: options.key,\n            attributionsCollapsible: options.attributionsCollapsible,\n            zDirection: options.zDirection,\n        }) || this;\n        /**\n         * @protected\n         * @type {?string}\n         */\n        _this.crossOrigin =\n            options.crossOrigin !== undefined ? options.crossOrigin : null;\n        /**\n         * @protected\n         * @type {typeof ImageTile}\n         */\n        _this.tileClass =\n            options.tileClass !== undefined ? options.tileClass : ImageTile;\n        /**\n         * @protected\n         * @type {!Object<string, TileCache>}\n         */\n        _this.tileCacheForProjection = {};\n        /**\n         * @protected\n         * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n         */\n        _this.tileGridForProjection = {};\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderReprojectionEdges_ = false;\n        return _this;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    TileImage.prototype.canExpireCache = function () {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            return _super.prototype.canExpireCache.call(this);\n        }\n        if (this.tileCache.canExpireCache()) {\n            return true;\n        }\n        else {\n            for (var key in this.tileCacheForProjection) {\n                if (this.tileCacheForProjection[key].canExpireCache()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    TileImage.prototype.expireCache = function (projection, usedTiles) {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            _super.prototype.expireCache.call(this, projection, usedTiles);\n            return;\n        }\n        var usedTileCache = this.getTileCacheForProjection(projection);\n        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n        for (var id in this.tileCacheForProjection) {\n            var tileCache = this.tileCacheForProjection[id];\n            tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {number} Gutter.\n     */\n    TileImage.prototype.getGutterForProjection = function (projection) {\n        if (ENABLE_RASTER_REPROJECTION &&\n            this.getProjection() &&\n            projection &&\n            !equivalent(this.getProjection(), projection)) {\n            return 0;\n        }\n        else {\n            return this.getGutter();\n        }\n    };\n    /**\n     * @return {number} Gutter.\n     */\n    TileImage.prototype.getGutter = function () {\n        return 0;\n    };\n    /**\n     * Return the key to be used for all tiles in the source.\n     * @return {string} The key for all tiles.\n     */\n    TileImage.prototype.getKey = function () {\n        var key = _super.prototype.getKey.call(this);\n        if (!this.getInterpolate()) {\n            key += ':disable-interpolation';\n        }\n        return key;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {boolean} Opaque.\n     */\n    TileImage.prototype.getOpaque = function (projection) {\n        if (ENABLE_RASTER_REPROJECTION &&\n            this.getProjection() &&\n            projection &&\n            !equivalent(this.getProjection(), projection)) {\n            return false;\n        }\n        else {\n            return _super.prototype.getOpaque.call(this, projection);\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    TileImage.prototype.getTileGridForProjection = function (projection) {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            return _super.prototype.getTileGridForProjection.call(this, projection);\n        }\n        var thisProj = this.getProjection();\n        if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n            return this.tileGrid;\n        }\n        else {\n            var projKey = getUid(projection);\n            if (!(projKey in this.tileGridForProjection)) {\n                this.tileGridForProjection[projKey] =\n                    getTileGridForProjection(projection);\n            }\n            return this.tileGridForProjection[projKey];\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../TileCache.js\").default} Tile cache.\n     */\n    TileImage.prototype.getTileCacheForProjection = function (projection) {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            return _super.prototype.getTileCacheForProjection.call(this, projection);\n        }\n        var thisProj = this.getProjection();\n        if (!thisProj || equivalent(thisProj, projection)) {\n            return this.tileCache;\n        }\n        else {\n            var projKey = getUid(projection);\n            if (!(projKey in this.tileCacheForProjection)) {\n                this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);\n            }\n            return this.tileCacheForProjection[projKey];\n        }\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {string} key The key set on the tile.\n     * @return {!ImageTile} Tile.\n     * @private\n     */\n    TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {\n        var tileCoord = [z, x, y];\n        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var tileUrl = urlTileCoord\n            ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n            : undefined;\n        var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);\n        tile.key = key;\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n        return tile;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!(ImageTile|ReprojTile)} Tile.\n     */\n    TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var sourceProjection = this.getProjection();\n        if (!ENABLE_RASTER_REPROJECTION ||\n            !sourceProjection ||\n            !projection ||\n            equivalent(sourceProjection, projection)) {\n            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\n        }\n        else {\n            var cache = this.getTileCacheForProjection(projection);\n            var tileCoord = [z, x, y];\n            var tile = void 0;\n            var tileCoordKey = getKey(tileCoord);\n            if (cache.containsKey(tileCoordKey)) {\n                tile = cache.get(tileCoordKey);\n            }\n            var key = this.getKey();\n            if (tile && tile.key == key) {\n                return tile;\n            }\n            else {\n                var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n                var targetTileGrid = this.getTileGridForProjection(projection);\n                var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n                var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {\n                    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n                }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());\n                newTile.key = key;\n                if (tile) {\n                    newTile.interimTile = tile;\n                    newTile.refreshInterimChain();\n                    cache.replace(tileCoordKey, newTile);\n                }\n                else {\n                    cache.set(tileCoordKey, newTile);\n                }\n                return newTile;\n            }\n        }\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!(ImageTile|ReprojTile)} Tile.\n     * @protected\n     */\n    TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {\n        var tile = null;\n        var tileCoordKey = getKeyZXY(z, x, y);\n        var key = this.getKey();\n        if (!this.tileCache.containsKey(tileCoordKey)) {\n            tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n            this.tileCache.set(tileCoordKey, tile);\n        }\n        else {\n            tile = this.tileCache.get(tileCoordKey);\n            if (tile.key != key) {\n                // The source's params changed. If the tile has an interim tile and if we\n                // can use it then we use it. Otherwise we create a new tile.  In both\n                // cases we attempt to assign an interim tile to the new tile.\n                var interimTile = tile;\n                tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n                //make the new tile the head of the list,\n                if (interimTile.getState() == TileState.IDLE) {\n                    //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n                    tile.interimTile = interimTile.interimTile;\n                }\n                else {\n                    tile.interimTile = interimTile;\n                }\n                tile.refreshInterimChain();\n                this.tileCache.replace(tileCoordKey, tile);\n            }\n        }\n        return tile;\n    };\n    /**\n     * Sets whether to render reprojection edges or not (usually for debugging).\n     * @param {boolean} render Render the edges.\n     * @api\n     */\n    TileImage.prototype.setRenderReprojectionEdges = function (render) {\n        if (!ENABLE_RASTER_REPROJECTION ||\n            this.renderReprojectionEdges_ == render) {\n            return;\n        }\n        this.renderReprojectionEdges_ = render;\n        for (var id in this.tileCacheForProjection) {\n            this.tileCacheForProjection[id].clear();\n        }\n        this.changed();\n    };\n    /**\n     * Sets the tile grid to use when reprojecting the tiles to the given\n     * projection instead of the default tile grid for the projection.\n     *\n     * This can be useful when the default tile grid cannot be created\n     * (e.g. projection has no extent defined) or\n     * for optimization reasons (custom tile size, resolutions, ...).\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n     * @api\n     */\n    TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {\n        if (ENABLE_RASTER_REPROJECTION) {\n            var proj = getProjection(projection);\n            if (proj) {\n                var projKey = getUid(proj);\n                if (!(projKey in this.tileGridForProjection)) {\n                    this.tileGridForProjection[projKey] = tilegrid;\n                }\n            }\n        }\n    };\n    return TileImage;\n}(UrlTile));\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n    /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =\n        src;\n}\nexport default TileImage;\n//# sourceMappingURL=TileImage.js.map","/**\n * @module ol/TileRange\n */\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nvar TileRange = /** @class */ (function () {\n    /**\n     * @param {number} minX Minimum X.\n     * @param {number} maxX Maximum X.\n     * @param {number} minY Minimum Y.\n     * @param {number} maxY Maximum Y.\n     */\n    function TileRange(minX, maxX, minY, maxY) {\n        /**\n         * @type {number}\n         */\n        this.minX = minX;\n        /**\n         * @type {number}\n         */\n        this.maxX = maxX;\n        /**\n         * @type {number}\n         */\n        this.minY = minY;\n        /**\n         * @type {number}\n         */\n        this.maxY = maxY;\n    }\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {boolean} Contains tile coordinate.\n     */\n    TileRange.prototype.contains = function (tileCoord) {\n        return this.containsXY(tileCoord[1], tileCoord[2]);\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Contains.\n     */\n    TileRange.prototype.containsTileRange = function (tileRange) {\n        return (this.minX <= tileRange.minX &&\n            tileRange.maxX <= this.maxX &&\n            this.minY <= tileRange.minY &&\n            tileRange.maxY <= this.maxY);\n    };\n    /**\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @return {boolean} Contains coordinate.\n     */\n    TileRange.prototype.containsXY = function (x, y) {\n        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Equals.\n     */\n    TileRange.prototype.equals = function (tileRange) {\n        return (this.minX == tileRange.minX &&\n            this.minY == tileRange.minY &&\n            this.maxX == tileRange.maxX &&\n            this.maxY == tileRange.maxY);\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     */\n    TileRange.prototype.extend = function (tileRange) {\n        if (tileRange.minX < this.minX) {\n            this.minX = tileRange.minX;\n        }\n        if (tileRange.maxX > this.maxX) {\n            this.maxX = tileRange.maxX;\n        }\n        if (tileRange.minY < this.minY) {\n            this.minY = tileRange.minY;\n        }\n        if (tileRange.maxY > this.maxY) {\n            this.maxY = tileRange.maxY;\n        }\n    };\n    /**\n     * @return {number} Height.\n     */\n    TileRange.prototype.getHeight = function () {\n        return this.maxY - this.minY + 1;\n    };\n    /**\n     * @return {import(\"./size.js\").Size} Size.\n     */\n    TileRange.prototype.getSize = function () {\n        return [this.getWidth(), this.getHeight()];\n    };\n    /**\n     * @return {number} Width.\n     */\n    TileRange.prototype.getWidth = function () {\n        return this.maxX - this.minX + 1;\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Intersects.\n     */\n    TileRange.prototype.intersects = function (tileRange) {\n        return (this.minX <= tileRange.maxX &&\n            this.maxX >= tileRange.minX &&\n            this.minY <= tileRange.maxY &&\n            this.maxY >= tileRange.minY);\n    };\n    return TileRange;\n}());\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n    if (tileRange !== undefined) {\n        tileRange.minX = minX;\n        tileRange.maxX = maxX;\n        tileRange.minY = minY;\n        tileRange.maxY = maxY;\n        return tileRange;\n    }\n    else {\n        return new TileRange(minX, maxX, minY, maxY);\n    }\n}\nexport default TileRange;\n//# sourceMappingURL=TileRange.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { listenImage } from './Image.js';\nvar ImageTile = /** @class */ (function (_super) {\n    __extends(ImageTile, _super);\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"./TileState.js\").default} state State.\n     * @param {string} src Image source URI.\n     * @param {?string} crossOrigin Cross origin.\n     * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n     * @param {import(\"./Tile.js\").Options} [opt_options] Tile options.\n     */\n    function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\n        var _this = _super.call(this, tileCoord, state, opt_options) || this;\n        /**\n         * @private\n         * @type {?string}\n         */\n        _this.crossOrigin_ = crossOrigin;\n        /**\n         * Image URI\n         *\n         * @private\n         * @type {string}\n         */\n        _this.src_ = src;\n        _this.key = src;\n        /**\n         * @private\n         * @type {HTMLImageElement|HTMLCanvasElement}\n         */\n        _this.image_ = new Image();\n        if (crossOrigin !== null) {\n            _this.image_.crossOrigin = crossOrigin;\n        }\n        /**\n         * @private\n         * @type {?function():void}\n         */\n        _this.unlisten_ = null;\n        /**\n         * @private\n         * @type {import(\"./Tile.js\").LoadFunction}\n         */\n        _this.tileLoadFunction_ = tileLoadFunction;\n        return _this;\n    }\n    /**\n     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n     * @api\n     */\n    ImageTile.prototype.getImage = function () {\n        return this.image_;\n    };\n    /**\n     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n     * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n     */\n    ImageTile.prototype.setImage = function (element) {\n        this.image_ = element;\n        this.state = TileState.LOADED;\n        this.unlistenImage_();\n        this.changed();\n    };\n    /**\n     * Tracks loading or read errors.\n     *\n     * @private\n     */\n    ImageTile.prototype.handleImageError_ = function () {\n        this.state = TileState.ERROR;\n        this.unlistenImage_();\n        this.image_ = getBlankImage();\n        this.changed();\n    };\n    /**\n     * Tracks successful image load.\n     *\n     * @private\n     */\n    ImageTile.prototype.handleImageLoad_ = function () {\n        var image = /** @type {HTMLImageElement} */ (this.image_);\n        if (image.naturalWidth && image.naturalHeight) {\n            this.state = TileState.LOADED;\n        }\n        else {\n            this.state = TileState.EMPTY;\n        }\n        this.unlistenImage_();\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     * @api\n     */\n    ImageTile.prototype.load = function () {\n        if (this.state == TileState.ERROR) {\n            this.state = TileState.IDLE;\n            this.image_ = new Image();\n            if (this.crossOrigin_ !== null) {\n                this.image_.crossOrigin = this.crossOrigin_;\n            }\n        }\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            this.tileLoadFunction_(this, this.src_);\n            this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));\n        }\n    };\n    /**\n     * Discards event handlers which listen for load completion or errors.\n     *\n     * @private\n     */\n    ImageTile.prototype.unlistenImage_ = function () {\n        if (this.unlisten_) {\n            this.unlisten_();\n            this.unlisten_ = null;\n        }\n    };\n    return ImageTile;\n}(Tile));\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n    var ctx = createCanvasContext2D(1, 1);\n    ctx.fillStyle = 'rgba(0,0,0,0)';\n    ctx.fillRect(0, 0, 1, 1);\n    return ctx.canvas;\n}\nexport default ImageTile;\n//# sourceMappingURL=ImageTile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED } from './common.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString, } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { containsCoordinate, createEmpty, equals, getHeight, getIntersection, getRotatedViewport, getTopLeft, getWidth, intersects, } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nvar CanvasTileLayerRenderer = /** @class */ (function (_super) {\n    __extends(CanvasTileLayerRenderer, _super);\n    /**\n     * @param {LayerType} tileLayer Tile layer.\n     */\n    function CanvasTileLayerRenderer(tileLayer) {\n        var _this = _super.call(this, tileLayer) || this;\n        /**\n         * Rendered extent has changed since the previous `renderFrame()` call\n         * @type {boolean}\n         */\n        _this.extentChanged = true;\n        /**\n         * @private\n         * @type {?import(\"../../extent.js\").Extent}\n         */\n        _this.renderedExtent_ = null;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.renderedPixelRatio;\n        /**\n         * @protected\n         * @type {import(\"../../proj/Projection.js\").default}\n         */\n        _this.renderedProjection = null;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.renderedRevision;\n        /**\n         * @protected\n         * @type {!Array<import(\"../../Tile.js\").default>}\n         */\n        _this.renderedTiles = [];\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.newTiles_ = false;\n        /**\n         * @protected\n         * @type {import(\"../../extent.js\").Extent}\n         */\n        _this.tmpExtent = createEmpty();\n        /**\n         * @private\n         * @type {import(\"../../TileRange.js\").default}\n         */\n        _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean} Tile is drawable.\n     */\n    CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n        var tileLayer = this.getLayer();\n        var tileState = tile.getState();\n        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n        return (tileState == TileState.LOADED ||\n            tileState == TileState.EMPTY ||\n            (tileState == TileState.ERROR && !useInterimTilesOnError));\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n    CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n        var pixelRatio = frameState.pixelRatio;\n        var projection = frameState.viewState.projection;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n        if (tile.getState() == TileState.ERROR) {\n            if (!tileLayer.getUseInterimTilesOnError()) {\n                // When useInterimTilesOnError is false, we consider the error tile as loaded.\n                tile.setState(TileState.LOADED);\n            }\n            else if (tileLayer.getPreload() > 0) {\n                // Preloaded tiles for lower resolutions might have finished loading.\n                this.newTiles_ = true;\n            }\n        }\n        if (!this.isDrawableTile(tile)) {\n            tile = tile.getInterimTile();\n        }\n        return tile;\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Uint8ClampedArray} Data at the pixel location.\n     */\n    CanvasTileLayerRenderer.prototype.getData = function (pixel) {\n        var frameState = this.frameState;\n        if (!frameState) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            if (!containsCoordinate(layerExtent, coordinate)) {\n                return null;\n            }\n        }\n        var pixelRatio = frameState.pixelRatio;\n        var projection = frameState.viewState.projection;\n        var viewState = frameState.viewState;\n        var source = layer.getRenderSource();\n        var tileGrid = source.getTileGridForProjection(viewState.projection);\n        var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n        for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n            var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n            var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n            if (!(tile instanceof ImageTile || tile instanceof ReprojTile)) {\n                return null;\n            }\n            if (tile.getState() !== TileState.LOADED) {\n                continue;\n            }\n            var tileOrigin = tileGrid.getOrigin(z);\n            var tileSize = toSize(tileGrid.getTileSize(z));\n            var tileResolution = tileGrid.getResolution(z);\n            var col = Math.floor(tilePixelRatio *\n                ((coordinate[0] - tileOrigin[0]) / tileResolution -\n                    tileCoord[1] * tileSize[0]));\n            var row = Math.floor(tilePixelRatio *\n                ((tileOrigin[1] - coordinate[1]) / tileResolution -\n                    tileCoord[2] * tileSize[1]));\n            var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n            return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n        }\n        return null;\n    };\n    /**\n     * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @param {number} zoom Zoom level.\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean|void} If `false`, the tile will not be considered loaded.\n     */\n    CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n        if (this.isDrawableTile(tile)) {\n            return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n        }\n        return false;\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n        return !!this.getLayer().getSource();\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n    CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var viewResolution = viewState.resolution;\n        var viewCenter = viewState.center;\n        var rotation = viewState.rotation;\n        var pixelRatio = frameState.pixelRatio;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var sourceRevision = tileSource.getRevision();\n        var tileGrid = tileSource.getTileGridForProjection(projection);\n        var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n        var tileResolution = tileGrid.getResolution(z);\n        var extent = frameState.extent;\n        var resolution = frameState.viewState.resolution;\n        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n        // desired dimensions of the canvas in pixels\n        var width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n        var height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n        var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n        if (layerExtent) {\n            extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n        }\n        var dx = (tileResolution * width) / 2 / tilePixelRatio;\n        var dy = (tileResolution * height) / 2 / tilePixelRatio;\n        var canvasExtent = [\n            viewCenter[0] - dx,\n            viewCenter[1] - dy,\n            viewCenter[0] + dx,\n            viewCenter[1] + dy,\n        ];\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n        /**\n         * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n         */\n        var tilesToDrawByZ = {};\n        tilesToDrawByZ[z] = {};\n        var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n        var tmpExtent = this.tmpExtent;\n        var tmpTileRange = this.tmpTileRange_;\n        this.newTiles_ = false;\n        var viewport = rotation\n            ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size)\n            : undefined;\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                if (rotation &&\n                    !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n                    continue;\n                }\n                var tile = this.getTile(z, x, y, frameState);\n                if (this.isDrawableTile(tile)) {\n                    var uid = getUid(this);\n                    if (tile.getState() == TileState.LOADED) {\n                        tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n                        var inTransition = tile.inTransition(uid);\n                        if (inTransition && layerState.opacity !== 1) {\n                            // Skipping transition when layer is not fully opaque avoids visual artifacts.\n                            tile.endTransition(uid);\n                            inTransition = false;\n                        }\n                        if (!this.newTiles_ &&\n                            (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n                            this.newTiles_ = true;\n                        }\n                    }\n                    if (tile.getAlpha(uid, frameState.time) === 1) {\n                        // don't look for alt tiles if alpha is 1\n                        continue;\n                    }\n                }\n                var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n                var covered = false;\n                if (childTileRange) {\n                    covered = findLoadedTiles(z + 1, childTileRange);\n                }\n                if (!covered) {\n                    tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n                }\n            }\n        }\n        var canvasScale = ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n        // set forward and inverse pixel transforms\n        composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n        var canvasTransform = toTransformString(this.pixelTransform);\n        this.useContainer(target, canvasTransform, this.getBackground(frameState));\n        var context = this.context;\n        var canvas = context.canvas;\n        makeInverse(this.inversePixelTransform, this.pixelTransform);\n        // set scale transform for calculating tile positions on the canvas\n        composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n        if (canvas.width != width || canvas.height != height) {\n            canvas.width = width;\n            canvas.height = height;\n        }\n        else if (!this.containerReused) {\n            context.clearRect(0, 0, width, height);\n        }\n        if (layerExtent) {\n            this.clipUnrotated(context, frameState, layerExtent);\n        }\n        if (!tileSource.getInterpolate()) {\n            assign(context, IMAGE_SMOOTHING_DISABLED);\n        }\n        this.preRender(context, frameState);\n        this.renderedTiles.length = 0;\n        /** @type {Array<number>} */\n        var zs = Object.keys(tilesToDrawByZ).map(Number);\n        zs.sort(numberSafeCompareFunction);\n        var clips, clipZs, currentClip;\n        if (layerState.opacity === 1 &&\n            (!this.containerReused ||\n                tileSource.getOpaque(frameState.viewState.projection))) {\n            zs = zs.reverse();\n        }\n        else {\n            clips = [];\n            clipZs = [];\n        }\n        for (var i = zs.length - 1; i >= 0; --i) {\n            var currentZ = zs[i];\n            var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n            var currentResolution = tileGrid.getResolution(currentZ);\n            var currentScale = currentResolution / tileResolution;\n            var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n            var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n            var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n            var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n            var origin_1 = applyTransform(this.tempTransform, [\n                (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n                    tileResolution,\n                (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n                    tileResolution,\n            ]);\n            var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n            var tilesToDraw = tilesToDrawByZ[currentZ];\n            for (var tileCoordKey in tilesToDraw) {\n                var tile = /** @type {import(\"../../ImageTile.js\").default} */ (tilesToDraw[tileCoordKey]);\n                var tileCoord = tile.tileCoord;\n                // Calculate integer positions and sizes so that tiles align\n                var xIndex = originTileCoord[1] - tileCoord[1];\n                var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n                var yIndex = originTileCoord[2] - tileCoord[2];\n                var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n                var x = Math.round(origin_1[0] - xIndex * dx_1);\n                var y = Math.round(origin_1[1] - yIndex * dy_1);\n                var w = nextX - x;\n                var h = nextY - y;\n                var transition = z === currentZ;\n                var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n                var contextSaved = false;\n                if (!inTransition) {\n                    if (clips) {\n                        // Clip mask for regions in this tile that already filled by a higher z tile\n                        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n                        for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n                            if (z !== currentZ && currentZ < clipZs[i_1]) {\n                                var clip = clips[i_1];\n                                if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                                    if (!contextSaved) {\n                                        context.save();\n                                        contextSaved = true;\n                                    }\n                                    context.beginPath();\n                                    // counter-clockwise (outer ring) for current tile\n                                    context.moveTo(currentClip[0], currentClip[1]);\n                                    context.lineTo(currentClip[2], currentClip[3]);\n                                    context.lineTo(currentClip[4], currentClip[5]);\n                                    context.lineTo(currentClip[6], currentClip[7]);\n                                    // clockwise (inner ring) for higher z tile\n                                    context.moveTo(clip[6], clip[7]);\n                                    context.lineTo(clip[4], clip[5]);\n                                    context.lineTo(clip[2], clip[3]);\n                                    context.lineTo(clip[0], clip[1]);\n                                    context.clip();\n                                }\n                            }\n                        }\n                        clips.push(currentClip);\n                        clipZs.push(currentZ);\n                    }\n                    else {\n                        context.clearRect(x, y, w, h);\n                    }\n                }\n                this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n                if (clips && !inTransition) {\n                    if (contextSaved) {\n                        context.restore();\n                    }\n                    this.renderedTiles.unshift(tile);\n                }\n                else {\n                    this.renderedTiles.push(tile);\n                }\n                this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n            }\n        }\n        this.renderedRevision = sourceRevision;\n        this.renderedResolution = tileResolution;\n        this.extentChanged =\n            !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n        this.renderedExtent_ = canvasExtent;\n        this.renderedPixelRatio = pixelRatio;\n        this.renderedProjection = projection;\n        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n        this.scheduleExpireCache(frameState, tileSource);\n        this.postRender(context, frameState);\n        if (layerState.extent) {\n            context.restore();\n        }\n        assign(context, IMAGE_SMOOTHING_ENABLED);\n        if (canvasTransform !== canvas.style.transform) {\n            canvas.style.transform = canvasTransform;\n        }\n        return this.container;\n    };\n    /**\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} x Left of the tile.\n     * @param {number} y Top of the tile.\n     * @param {number} w Width of the tile.\n     * @param {number} h Height of the tile.\n     * @param {number} gutter Tile gutter.\n     * @param {boolean} transition Apply an alpha transition.\n     */\n    CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {\n        var image = this.getTileImage(tile);\n        if (!image) {\n            return;\n        }\n        var uid = getUid(this);\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var alpha = layerState.opacity *\n            (transition ? tile.getAlpha(uid, frameState.time) : 1);\n        var alphaChanged = alpha !== this.context.globalAlpha;\n        if (alphaChanged) {\n            this.context.save();\n            this.context.globalAlpha = alpha;\n        }\n        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n        if (alphaChanged) {\n            this.context.restore();\n        }\n        if (alpha !== layerState.opacity) {\n            frameState.animate = true;\n        }\n        else if (transition) {\n            tile.endTransition(uid);\n        }\n    };\n    /**\n     * @return {HTMLCanvasElement} Image\n     */\n    CanvasTileLayerRenderer.prototype.getImage = function () {\n        var context = this.context;\n        return context ? context.canvas : null;\n    };\n    /**\n     * Get the image from a tile.\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n        return tile.getImage();\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n        if (tileSource.canExpireCache()) {\n            /**\n             * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n             * @param {import(\"../../PluggableMap.js\").default} map Map.\n             * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n             */\n            var postRenderFunction = function (tileSource, map, frameState) {\n                var tileSourceKey = getUid(tileSource);\n                if (tileSourceKey in frameState.usedTiles) {\n                    tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n                }\n            }.bind(null, tileSource);\n            frameState.postRenderFunctions.push(\n            /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (postRenderFunction));\n        }\n    };\n    /**\n     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import('../../Tile.js').default} tile Tile.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n        // FIXME should we use tilesToDrawByZ instead?\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in usedTiles)) {\n            usedTiles[tileSourceKey] = {};\n        }\n        usedTiles[tileSourceKey][tile.getKey()] = true;\n    };\n    /**\n     * Manage tile pyramid.\n     * This function performs a number of functions related to the tiles at the\n     * current zoom and lower zoom levels:\n     * - registers idle tiles in frameState.wantedTiles so that they are not\n     *   discarded by the tile queue\n     * - enqueues missing tiles\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @param {number} currentZ Current Z.\n     * @param {number} preload Load low resolution tiles up to `preload` levels.\n     * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n     * @protected\n     */\n    CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in frameState.wantedTiles)) {\n            frameState.wantedTiles[tileSourceKey] = {};\n        }\n        var wantedTiles = frameState.wantedTiles[tileSourceKey];\n        var tileQueue = frameState.tileQueue;\n        var minZoom = tileGrid.getMinZoom();\n        var rotation = frameState.viewState.rotation;\n        var viewport = rotation\n            ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size)\n            : undefined;\n        var tileCount = 0;\n        var tile, tileRange, tileResolution, x, y, z;\n        for (z = minZoom; z <= currentZ; ++z) {\n            tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n            tileResolution = tileGrid.getResolution(z);\n            for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n                for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                    if (rotation &&\n                        !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n                        continue;\n                    }\n                    if (currentZ - z <= preload) {\n                        ++tileCount;\n                        tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n                        if (tile.getState() == TileState.IDLE) {\n                            wantedTiles[tile.getKey()] = true;\n                            if (!tileQueue.isKeyQueued(tile.getKey())) {\n                                tileQueue.enqueue([\n                                    tile,\n                                    tileSourceKey,\n                                    tileGrid.getTileCoordCenter(tile.tileCoord),\n                                    tileResolution,\n                                ]);\n                            }\n                        }\n                        if (opt_tileCallback !== undefined) {\n                            opt_tileCallback(tile);\n                        }\n                    }\n                    else {\n                        tileSource.useTile(z, x, y, projection);\n                    }\n                }\n            }\n        }\n        tileSource.updateCacheSize(tileCount, projection);\n    };\n    return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer));\nexport default CanvasTileLayerRenderer;\n//# sourceMappingURL=TileLayer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nvar TileLayer = /** @class */ (function (_super) {\n    __extends(TileLayer, _super);\n    /**\n     * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [opt_options] Tile layer options.\n     */\n    function TileLayer(opt_options) {\n        return _super.call(this, opt_options) || this;\n    }\n    TileLayer.prototype.createRenderer = function () {\n        return new CanvasTileLayerRenderer(this);\n    };\n    return TileLayer;\n}(BaseTileLayer));\nexport default TileLayer;\n//# sourceMappingURL=Tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport { abstract } from './util.js';\nimport { easeIn } from './easing.js';\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   var xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     var data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nvar Tile = /** @class */ (function (_super) {\n    __extends(Tile, _super);\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"./TileState.js\").default} state State.\n     * @param {Options} [opt_options] Tile options.\n     */\n    function Tile(tileCoord, state, opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @type {import(\"./tilecoord.js\").TileCoord}\n         */\n        _this.tileCoord = tileCoord;\n        /**\n         * @protected\n         * @type {import(\"./TileState.js\").default}\n         */\n        _this.state = state;\n        /**\n         * An \"interim\" tile for this tile. The interim tile may be used while this\n         * one is loading, for \"smooth\" transitions when changing params/dimensions\n         * on the source.\n         * @type {Tile}\n         */\n        _this.interimTile = null;\n        /**\n         * A key assigned to the tile. This is used by the tile source to determine\n         * if this tile can effectively be used, or if a new tile should be created\n         * and this one be used as an interim tile for this new tile.\n         * @type {string}\n         */\n        _this.key = '';\n        /**\n         * The duration for the opacity transition.\n         * @type {number}\n         */\n        _this.transition_ =\n            options.transition === undefined ? 250 : options.transition;\n        /**\n         * Lookup of start times for rendering transitions.  If the start time is\n         * equal to -1, the transition is complete.\n         * @type {Object<string, number>}\n         */\n        _this.transitionStarts_ = {};\n        /**\n         * @type {boolean}\n         */\n        _this.interpolate = !!options.interpolate;\n        return _this;\n    }\n    /**\n     * @protected\n     */\n    Tile.prototype.changed = function () {\n        this.dispatchEvent(EventType.CHANGE);\n    };\n    /**\n     * Called by the tile cache when the tile is removed from the cache due to expiry\n     */\n    Tile.prototype.release = function () { };\n    /**\n     * @return {string} Key.\n     */\n    Tile.prototype.getKey = function () {\n        return this.key + '/' + this.tileCoord;\n    };\n    /**\n     * Get the interim tile most suitable for rendering using the chain of interim\n     * tiles. This corresponds to the  most recent tile that has been loaded, if no\n     * such tile exists, the original tile is returned.\n     * @return {!Tile} Best tile for rendering.\n     */\n    Tile.prototype.getInterimTile = function () {\n        if (!this.interimTile) {\n            //empty chain\n            return this;\n        }\n        var tile = this.interimTile;\n        // find the first loaded tile and return it. Since the chain is sorted in\n        // decreasing order of creation time, there is no need to search the remainder\n        // of the list (all those tiles correspond to older requests and will be\n        // cleaned up by refreshInterimChain)\n        do {\n            if (tile.getState() == TileState.LOADED) {\n                // Show tile immediately instead of fading it in after loading, because\n                // the interim tile is in place already\n                this.transition_ = 0;\n                return tile;\n            }\n            tile = tile.interimTile;\n        } while (tile);\n        // we can not find a better tile\n        return this;\n    };\n    /**\n     * Goes through the chain of interim tiles and discards sections of the chain\n     * that are no longer relevant.\n     */\n    Tile.prototype.refreshInterimChain = function () {\n        if (!this.interimTile) {\n            return;\n        }\n        var tile = this.interimTile;\n        /**\n         * @type {Tile}\n         */\n        var prev = this;\n        do {\n            if (tile.getState() == TileState.LOADED) {\n                //we have a loaded tile, we can discard the rest of the list\n                //we would could abort any LOADING tile request\n                //older than this tile (i.e. any LOADING tile following this entry in the chain)\n                tile.interimTile = null;\n                break;\n            }\n            else if (tile.getState() == TileState.LOADING) {\n                //keep this LOADING tile any loaded tiles later in the chain are\n                //older than this tile, so we're still interested in the request\n                prev = tile;\n            }\n            else if (tile.getState() == TileState.IDLE) {\n                //the head of the list is the most current tile, we don't need\n                //to start any other requests for this chain\n                prev.interimTile = tile.interimTile;\n            }\n            else {\n                prev = tile;\n            }\n            tile = prev.interimTile;\n        } while (tile);\n    };\n    /**\n     * Get the tile coordinate for this tile.\n     * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n     * @api\n     */\n    Tile.prototype.getTileCoord = function () {\n        return this.tileCoord;\n    };\n    /**\n     * @return {import(\"./TileState.js\").default} State.\n     */\n    Tile.prototype.getState = function () {\n        return this.state;\n    };\n    /**\n     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n     * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n     * the tile queue and will block other requests.\n     * @param {import(\"./TileState.js\").default} state State.\n     * @api\n     */\n    Tile.prototype.setState = function (state) {\n        if (this.state !== TileState.ERROR && this.state > state) {\n            throw new Error('Tile load sequence violation');\n        }\n        this.state = state;\n        this.changed();\n    };\n    /**\n     * Load the image or retry if loading previously failed.\n     * Loading is taken care of by the tile queue, and calling this method is\n     * only needed for preloading or for reloading in case of an error.\n     * @abstract\n     * @api\n     */\n    Tile.prototype.load = function () {\n        abstract();\n    };\n    /**\n     * Get the alpha value for rendering.\n     * @param {string} id An id for the renderer.\n     * @param {number} time The render frame time.\n     * @return {number} A number between 0 and 1.\n     */\n    Tile.prototype.getAlpha = function (id, time) {\n        if (!this.transition_) {\n            return 1;\n        }\n        var start = this.transitionStarts_[id];\n        if (!start) {\n            start = time;\n            this.transitionStarts_[id] = start;\n        }\n        else if (start === -1) {\n            return 1;\n        }\n        var delta = time - start + 1000 / 60; // avoid rendering at 0\n        if (delta >= this.transition_) {\n            return 1;\n        }\n        return easeIn(delta / this.transition_);\n    };\n    /**\n     * Determine if a tile is in an alpha transition.  A tile is considered in\n     * transition if tile.getAlpha() has not yet been called or has been called\n     * and returned 1.\n     * @param {string} id An id for the renderer.\n     * @return {boolean} The tile is in transition.\n     */\n    Tile.prototype.inTransition = function (id) {\n        if (!this.transition_) {\n            return false;\n        }\n        return this.transitionStarts_[id] !== -1;\n    };\n    /**\n     * Mark a transition as complete.\n     * @param {string} id An id for the renderer.\n     */\n    Tile.prototype.endTransition = function (id) {\n        if (this.transition_) {\n            this.transitionStarts_[id] = -1;\n        }\n    };\n    return Tile;\n}(EventTarget));\nexport default Tile;\n//# sourceMappingURL=Tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected, } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n     * @param {boolean} [opt_renderEdges] Render reprojection edges.\n     * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent\n            ? getIntersection(targetExtent, maxTargetExtent)\n            : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage(),\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n            else {\n                this.sourceTiles_.forEach(function (tile, i, arr) {\n                    var state = tile.getState();\n                    if (state == TileState.IDLE) {\n                        tile.load();\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    /**\n     * Remove from the cache due to expiry\n     */\n    ReprojTile.prototype.release = function () {\n        if (this.canvas_) {\n            releaseCanvas(this.canvas_.getContext('2d'));\n            canvasPool.push(this.canvas_);\n            this.canvas_ = null;\n        }\n        _super.prototype.release.call(this);\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n//# sourceMappingURL=Tile.js.map"],"sourceRoot":""}