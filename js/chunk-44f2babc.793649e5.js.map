{"version":3,"sources":["webpack:///./src/hooks/updateMapSize.js","webpack:///./src/views/map-controls/measure/index.js","webpack:///./src/views/map-controls/measure/index.vue","webpack:///./src/views/map-controls/measure/index.vue?8cec","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/MultiPoint.js","webpack:///./src/views/map-controls/measure/index.vue?0209","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/Circle.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/flat/interpolate.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/MultiPolygon.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/flat/center.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/MultiLineString.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/interaction/Draw.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/LineString.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/Overlay.js"],"names":["map","targetNode","document","querySelector","observer","MutationObserver","mutationsList","mutation","type","attributeName","i","length","updateSize","observe","attributes","childList","subtree","onBeforeUnmount","disconnect","createMeasureTooltip","measureTooltipElement","parentNode","removeChild","newMeasureTooltipElement","createElement","className","measureTooltip","Overlay","element","offset","positioning","addOverlay","raster","TileLayer","source","XYZ","attributions","ATTRIBUTIONS","url","MAPURL","maxZoom","Vector","state","reactive","checked","typeSelect","options","label","value","sketch","helpTooltipElement","helpTooltip","draw","loadVector","vector","style","Style","fill","Fill","color","stroke","Stroke","width","image","Circle","radius","createVector","addLayer","pointerMoveHandler","evt","dragging","helpMsg","getGeometry","Polygon","LineString","innerHTML","setPosition","coordinate","classList","remove","addInteraction","listener","Draw","lineDash","drawGeometricFigure","newHelpTooltipElement","createHelpTooltip","on","feature","tooltipCoord","geom","target","output","polygon","area","sourceProj","getView","getProjection","clone","transform","Math","abs","getArea","projection","round","formatArea","getInteriorPoint","getCoordinates","line","getLength","formatLength","getLastCoordinate","this","setOffset","unByKey","handleChange","removeInteraction","onMounted","Map","layers","view","View","center","zoom","updateMapSize","getViewport","addEventListener","add","__exports__","extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","MultiPoint","_super","coordinates","opt_layout","_this","isArray","setFlatCoordinates","setCoordinates","appendPoint","point","flatCoordinates","getFlatCoordinates","slice","changed","multiPoint","layout","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","stride","ii","squaredDistance","j","getPoint","index","n","getPoints","points","push","getType","intersectsExtent","extent","setLayout","opt_radius","undefined","setCenterAndRadius","circle","dx","dy","delta","getRadius","sqrt","containsXY","getRadiusSquared_","getCenter","computeExtent","circleExtent","intersectsCoordinate","bind","setCenter","setRadius","rotate","angle","anchor","getStride","translate","deltaX","deltaY","interpolatePoint","end","fraction","opt_dest","opt_dimension","o","t","x1","y1","length_1","cumulativeLengths","x2","y2","dimension","dest","NaN","lineStringCoordinateAtM","m","extrapolate","lo","hi","mid","m0","lineStringsCoordinateAtM","ends","interpolate","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","getLayout","polygons","endss","getEnds","jj","appendPolygon","len","newEndss","multiPolygon","getRevision","getOrientedFlatCoordinates","opt_right","orient","inflate","getEndss","getFlatInteriorPoints","flatCenters","linearRingss","getInteriorPoints","GeometryLayout","XYM","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","XY","getPolygon","prevEnds","getPolygons","deflate","lastEnds","SimpleGeometry","MultiLineString","opt_ends","ends_","lineStrings","lineString","appendLineString","multiLineString","getCoordinateAtM","opt_extrapolate","opt_interpolate","XYZM","getLineString","getLineStrings","getFlatMidpoints","midpoints","midpoint","simplifiedEnds","Mode","DrawEventType","DrawEvent","pointerOptions","stopDown","once","un","shouldHandle_","downPx_","downTimeout_","lastDragTime_","pointerType_","freehand_","source_","features_","features","snapTolerance_","snapTolerance","type_","mode_","Error","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","Infinity","finishCondition_","finishCondition","geometryLayout_","geometryLayout","styles","geometryFunction","Constructor_1","mode_1","geometry","squaredLength","userProjection","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","useSpatialIndex","wrapX","resolution","updateWhileInteracting","geometryName_","geometryName","condition_","condition","freehandCondition_","freehand","freehandCondition","addChangeListener","ACTIVE","updateState_","setMap","getOverlay","handleEvent","event","originalEvent","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","Date","now","pixel","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","handleDownEvent","startDrawing_","setTimeout","frameState","handleUpEvent","startingToDraw","finishDrawing","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","mode","sketchCoords","getMap","finishCoordinate","finishPixel","getPixelFromCoordinate","updateSketchFeatures_","createOrUpdateCustomSketchLine_","ring","getLinearRing","sketchLineGeom","setGeometry","start","setGeometryName","dispatchEvent","last","done","pop","removeLastPoint","splice","sketchFeature","abortDrawing_","addFeature","getSource","clear","appendCoordinates","newDrawing","shift","ending","extend","sketchFeatures","overlaySource","addFeatures","active","getActive","createRegularPolygon","opt_sides","opt_angle","opt_geometry","atan2","flatMidpoint_","flatMidpointRevision_","appendCoordinate","forEachSegment","callback","getCoordinateAt","getFlatMidpoint","Property","id","insertFirst","stopEvent","position","pointerEvents","autoPan","animation","autoPanAnimation","margin","autoPanMargin","rendered","transform_","visible","mapPostrenderListenerKey","handleElementChanged","handleMapChanged","handleOffsetChanged","handlePositionChanged","handlePositioningChanged","setElement","setPositioning","getElement","get","getId","getOffset","getPosition","getPositioning","appendChild","POSTRENDER","render","updatePixelPosition","container","getOverlayContainerStopEvent","getOverlayContainer","insertBefore","childNodes","performAutoPan","set","panIntoView","opt_panIntoViewOptions","getTargetElement","mapRect","getRect","getSize","overlayRect","panIntoViewOptions","myMargin","offsetLeft","offsetRight","offsetTop","offsetBottom","getCenterInternal","centerPx","getPixelFromCoordinateInternal","newCenterPx","panOptions","animateInternal","getCoordinateFromPixelInternal","duration","easing","size","box","getBoundingClientRect","offsetX","left","window","pageXOffset","offsetY","top","pageYOffset","setVisible","display","isRendered","mapSize","updateRenderedPosition","posX","posY","msTransform","getOptions"],"mappings":"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","file":"js/chunk-44f2babc.793649e5.js","sourcesContent":["import { onBeforeUnmount } from \"vue\";\n\n/**\n * 监听侧边栏，侧边栏发生变化更新地图\n * @param {ol.Map} map 地图实例\n */\nexport default (...map) => {\n  // 选择需要观察变动的节点\n  const targetNode = document.querySelector(\n    \".el-aside .menu .el-scrollbar__view\"\n  );\n  // 观察器的配置（需要观察什么变动）\n  const config = { attributes: true, childList: true, subtree: true };\n  // 当观察到变动时执行的回调函数\n  const callback = function (mutationsList) {\n    // Use traditional 'for loops' for IE 11\n    for (let mutation of mutationsList) {\n      if (mutation.type === \"childList\") {\n        // console.log(\"已添加或删除子节点。\");\n      } else if (\n        mutation.type === \"attributes\" &&\n        mutation.attributeName === \"style\"\n      ) {\n        for (let i = 0; i < map.length; i++) {\n          map[i].updateSize();\n        }\n\n        // console.log(\"这个 \" + mutation.attributeName + \" 属性被修改。\");\n      }\n    }\n  };\n  // 创建一个观察器实例并传入回调函数\n  const observer = new MutationObserver(callback);\n\n  // 以上述配置开始观察目标节点\n  observer.observe(targetNode, config);\n\n  //卸载前\n  onBeforeUnmount(() => {\n    observer.disconnect();\n  });\n};\n","import { Overlay } from \"ol\";\nimport { getLength, getArea } from \"ol/sphere\";\nimport { Style, Fill, Stroke, Circle } from \"ol/style\";\nimport { Draw } from \"ol/interaction\";\nimport { Vector } from \"ol/layer\"\n/**\n * 创建一个新的帮助提示框（tooltip）\n * @param {Element} helpTooltipElement  帮助提示框对象\n * @param {ol.Map} map  地图实例\n */\nexport function createHelpTooltip({ helpTooltipElement, map }) {\n  if (helpTooltipElement) {\n    helpTooltipElement.parentNode.removeChild(helpTooltipElement);\n  }\n  const newHelpTooltipElement = document.createElement(\"div\");\n  newHelpTooltipElement.className = \"tooltip hidden\";\n  const helpTooltip = new Overlay({\n    element: newHelpTooltipElement,\n    offset: [15, 0],\n    positioning: \"center-left\",\n  });\n  map.addOverlay(helpTooltip);\n  return [newHelpTooltipElement, helpTooltip]\n}\n\n\n/**\n* 创建一个新的测量工具提示框（tooltip）\n* @param {Element} measureTooltipElement  测量工具提示框对象\n* @param {ol.Map} map  地图实例\n*/\nexport function createMeasureTooltip({ measureTooltipElement, map }) {\n  if (measureTooltipElement) {\n    measureTooltipElement.parentNode.removeChild(measureTooltipElement);\n  }\n  const newMeasureTooltipElement = document.createElement(\"div\");\n  newMeasureTooltipElement.className = \"tooltip tooltip-measure\";\n  const measureTooltip = new Overlay({\n    element: newMeasureTooltipElement,\n    offset: [0, -15],\n    positioning: \"bottom-center\",\n  });\n  map.addOverlay(measureTooltip);\n  return [newMeasureTooltipElement, measureTooltip]\n}\n\n/**\n * 测量长度输出\n * @param {boolean} checked 是否使用测地学方法测量\n * @param {ol.geom.LineString} line\n * @param {ol.Map} map  地图实例\n * @return {string}\n */\nexport function formatLength({ checked, line, map }) {\n  let length;\n  if (checked) {\n    //若使用测地学方法测量\n    const sourceProj = map.getView().getProjection(); //地图数据源投影坐标系\n    length = getLength(line, {\n      projection: sourceProj,\n      radius: 6378137,\n    });\n  } else {\n    length = Math.round(line.getLength() * 100) / 100; //直接得到线的长度\n  }\n  let output;\n  if (length > 100) {\n    output = Math.round((length / 1000) * 100) / 100 + \" \" + \"km\"; //换算成KM单位\n  } else {\n    output = Math.round(length * 100) / 100 + \" \" + \"m\"; //m为单位\n  }\n  return output; //返回线的长度\n}\n\n/**\n * 测量面积输出\n * @param {boolean} checked 是否使用测地学方法测量\n * @param {ol.geom.Polygon} polygon\n * @param {ol.Map} map  地图实例\n * @return {string}\n */\nexport function formatArea({ checked, polygon, map }) {\n  let area;\n  if (checked) {\n    //若使用测地学方法测量\n    const sourceProj = map.getView().getProjection(); //地图数据源投影坐标系\n    const geom = /** @type {ol.geom.Polygon} */ (\n      polygon.clone().transform(sourceProj, \"EPSG:4326\")\n    ); //将多边形要素坐标系投影为EPSG:4326\n    area = Math.abs(\n      getArea(geom, { projection: sourceProj, radius: 6378137 })\n    ); //获取面积\n  } else {\n    area = polygon.getArea(); //直接获取多边形的面积\n  }\n  let output;\n  if (area > 10000) {\n    output =\n      Math.round((area / 1000000) * 100) / 100 + \" \" + \"km<sup>2</sup>\"; //换算成KM单位\n  } else {\n    output = Math.round(area * 100) / 100 + \" \" + \"m<sup>2</sup>\"; //m为单位\n  }\n  return output; //返回多边形的面积\n}\n/**\n * 绘制几何图形\n * @param {ol.source.Vector} source 测量绘制层数据源\n * @param {ol.geom.GeometryType} type 几何图形类型\n * @return 返回绘制好的几何图形\n */\nexport function drawGeometricFigure({ source, type }) {\n  return new Draw({\n    source, //测量绘制层数据源\n    type, /** @type {ol.geom.GeometryType} 几何图形类型 */\n    style: new Style({\n      //绘制几何图形的样式\n      fill: new Fill({\n        color: \"rgba(255, 255, 255, 0.2)\",\n      }),\n      stroke: new Stroke({\n        color: \"rgba(0, 0, 0, 0.5)\",\n        lineDash: [10, 10],\n        width: 2,\n      }),\n      image: new Circle({\n        radius: 5,\n        stroke: new Stroke({\n          color: \"rgba(0, 0, 0, 0.7)\",\n        }),\n        fill: new Fill({\n          color: \"rgba(255, 255, 255, 0.2)\",\n        }),\n      }),\n    }),\n  });\n}\n\n// 创建测量的绘制矢量层\nexport function createVector(source) {\n  return new Vector({\n    source,\n    style: new Style({\n      //图层样式\n      fill: new Fill({\n        color: \"rgba(255, 255, 255, 0.2)\", //填充颜色\n      }),\n      stroke: new Stroke({\n        color: \"#ffcc33\", //边框颜色\n        width: 2, // 边框宽度\n      }),\n      image: new Circle({\n        radius: 7,\n        fill: new Fill({\n          color: \"#ffcc33\",\n        }),\n      }),\n    }),\n  })\n}","<template>\n  <div id=\"map\"></div>\n  <div id=\"menu\">\n    几何体类型\n    <el-select\n      v-model=\"state.typeSelect\"\n      placeholder=\"Select\"\n      size=\"small\"\n      @change=\"handleChange\"\n      class=\"select\"\n    >\n      <el-option\n        v-for=\"item in state.options\"\n        :key=\"item.value\"\n        :label=\"item.label\"\n        :value=\"item.value\"\n      />\n    </el-select>\n    <el-checkbox\n      v-model=\"state.checked\"\n      label=\"使用测地线的措施\"\n      size=\"large\"\n    />\n  </div>\n</template>\n\n<script setup>\nimport 'ol/ol.css'\nimport { onMounted, reactive } from 'vue'\nimport { Map, View } from 'ol'\nimport { Tile as TileLayer } from 'ol/layer'\nimport { Vector } from 'ol/source'\nimport { Polygon, LineString } from 'ol/geom'\nimport { unByKey } from 'ol/Observable'\nimport { MAPURL, ATTRIBUTIONS } from '@/constants'\nimport updateMapSize from '@/hooks/updateMapSize'\nimport XYZ from 'ol/source/XYZ'\nimport {\n  createHelpTooltip,\n  createMeasureTooltip,\n  formatLength,\n  formatArea,\n  drawGeometricFigure,\n  createVector,\n} from './index'\n\nconst raster = new TileLayer({\n  source: new XYZ({\n    attributions: ATTRIBUTIONS,\n    url: MAPURL,\n    maxZoom: 20,\n  }),\n})\n\n/**\n *  当用户正在绘制多边形时的提示信息文本\n * @type {string}\n */\nconst continuePolygonMsg = '单击继续绘制多边形'\n/**\n * 当用户正在绘制线时的提示信息文本\n * @type {string}\n */\nconst source = new Vector()\nconst continueLineMsg = '单击继续绘制直线'\nconst state = reactive({\n  checked: false,\n  typeSelect: 'length',\n  options: [\n    {\n      label: '长度',\n      value: 'length',\n    },\n    {\n      label: '面积',\n      value: 'area',\n    },\n  ],\n  map: null,\n  sketch: null, // 当前绘制的要素\n  helpTooltipElement: null, // 帮助提示框对象\n  helpTooltip: null, // 帮助提示框显示的信息\n  measureTooltipElement: null, // 测量工具提示框对象\n  measureTooltip: null, // 测量工具中显示的测量值\n  draw: null,\n})\n//初始化map\nconst initMap = () => {\n  state.map = new Map({\n    target: 'map',\n    //地图容器中加载的图层\n    layers: [\n      //加载瓦片图层数据\n      raster,\n    ],\n    view: new View({\n      projection: 'EPSG:4326', // 坐标系，有EPSG:4326和EPSG:3 857\n      center: [0, 0], // 深圳坐标\n      //地图初始显示级别\n      zoom: 5,\n    }),\n  })\n  // 侧边栏变化更新地图\n  updateMapSize(state.map)\n}\n\n// 加载测量的绘制矢量层\nconst loadVector = () => {\n  // 加载测量的绘制矢量层\n  const vector = createVector(source)\n  state.map.addLayer(vector)\n}\n/**\n * 鼠标移动事件处理函数\n * @param {ol.MapBrowserEvent} evt\n */\nconst pointerMoveHandler = (evt) => {\n  if (evt.dragging) {\n    return\n  }\n  /** @type {string} */\n  let helpMsg = '单击开始绘图' //当前默认提示信息\n  //判断绘制几何类型设置相应的帮助提示信息\n  if (state.sketch) {\n    const getGeometry = state.sketch.getGeometry()\n    if (getGeometry instanceof Polygon) {\n      helpMsg = continuePolygonMsg //绘制多边形时提示相应内容\n    } else if (getGeometry instanceof LineString) {\n      helpMsg = continueLineMsg //绘制线时提示相应内容\n    }\n  }\n  state.helpTooltipElement.innerHTML = helpMsg //将提示信息设置到对话框中显示\n  state.helpTooltip.setPosition(evt.coordinate) //设置帮助提示框的位置\n  state.helpTooltipElement.classList.remove('hidden')\n}\n\n/**\n * 加载交互绘制控件函数\n */\nconst addInteraction = () => {\n  const type = state.typeSelect === 'area' ? 'Polygon' : 'LineString'\n  state.draw = drawGeometricFigure({ source, type })\n  state.map.addInteraction(state.draw)\n  //创建测量工具提示框\n  ;[state.measureTooltipElement, state.measureTooltip] = createMeasureTooltip({\n    measureTooltipElement: state.measureTooltipElement,\n    map: state.map,\n  })\n  console.log(state.measureTooltipElement)\n  //创建帮助提示框\n  ;[state.helpTooltipElement, state.helpTooltip] = createHelpTooltip({\n    helpTooltipElement: state.helpTooltipElement,\n    map: state.map,\n  })\n  let listener\n  //绑定交互绘制工具开始绘制的事件\n  state.draw.on(\n    'drawstart',\n    function (evt) {\n      // set sketch\n      state.sketch = evt.feature //绘制的要素\n\n      /** @type {ol.Coordinate|undefined} */\n      let tooltipCoord = evt.coordinate // 绘制的坐标\n      //绑定change事件，根据绘制几何类型得到测量长度值或面积值，并将其设置到测量工具提示框中显示\n      listener = state.sketch.getGeometry().on('change', function (evt) {\n        const geom = evt.target //绘制几何要素\n        let output\n        if (geom instanceof Polygon) {\n          output = formatArea({\n            checked: state.checked,\n            polygon: geom,\n            map: state.map,\n          }) //面积值\n          tooltipCoord = geom.getInteriorPoint().getCoordinates() //坐标\n        } else if (geom instanceof LineString) {\n          output = formatLength({\n            checked: state.checked,\n            line: geom,\n            map: state.map,\n          }) //长度值\n          tooltipCoord = geom.getLastCoordinate() //坐标\n        }\n        state.measureTooltipElement.innerHTML = output //将测量值设置到测量工具提示框中显示\n        state.measureTooltip.setPosition(tooltipCoord) //设置测量工具提示框的显示位置\n      })\n    },\n    this\n  )\n  //绑定交互绘制工具结束绘制的事件\n  state.draw.on(\n    'drawend',\n    function () {\n      state.measureTooltipElement.className = 'tooltip tooltip-static' //设置测量提示框的样式\n      state.measureTooltip.setOffset([0, -7])\n      // 未设置的草图\n      state.sketch = null //置空当前绘制的要素对象\n      // 取消设置工具提示，以便创建新的工具提示\n      state.measureTooltipElement = null //置空测量工具提示框对象\n      //重新创建一个测试工具提示框显示结果\n      ;[state.measureTooltipElement, state.measureTooltip] =\n        createMeasureTooltip({\n          measureTooltipElement: state.measureTooltipElement,\n          map: state.map,\n        })\n      console.log(state.measureTooltipElement)\n      unByKey(listener)\n    },\n    this\n  )\n}\n\n// 让用户切换选择测量类型（长度/面积）\nconst handleChange = () => {\n  state.map.removeInteraction(state.draw) //移除绘制图形\n  addInteraction() //添加绘图进行测量\n}\nonMounted(() => {\n  initMap()\n  loadVector()\n\n  state.map.on('pointermove', pointerMoveHandler) //地图容器绑定鼠标移动事件，动态显示帮助提示框内容\n  //地图绑定鼠标移出事件，鼠标移出时为帮助提示框设置隐藏样式\n  state.map.getViewport().addEventListener('mouseout', () => {\n    state.helpTooltipElement.classList.add('hidden')\n  })\n  addInteraction() //调用加载绘制交互控件方法，添加绘图进行测量\n})\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n#map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n#menu {\n  width: 450px;\n  position: absolute;\n  left: 20px;\n  bottom: 20px;\n  color: #fff;\n  font-size: 20px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n/**\n    * 提示框的样式信息\n    */\n:deep(.tooltip) {\n  position: relative;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 4px;\n  color: white;\n  padding: 4px 8px;\n  opacity: 0.7;\n  white-space: nowrap;\n}\n\n:deep(.tooltip-measure) {\n  opacity: 1;\n  font-weight: bold;\n}\n\n:deep(.tooltip-static) {\n  background-color: #ffcc33;\n  color: black;\n  border: 1px solid white;\n}\n:deep(.tooltip-measure:before),\n:deep(.tooltip-static:before) {\n  border-top: 6px solid rgba(0, 0, 0, 0.5);\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  content: '';\n  position: absolute;\n  bottom: -6px;\n  margin-left: -7px;\n  left: 50%;\n}\n\n:deep(.tooltip-static:before) {\n  border-top-color: #ffcc33;\n}\n.mobile #menu {\n  width: 310px;\n  font-size: 14px;\n  bottom: 40px;\n}\n.mobile .select {\n  width: 80px;\n}\n</style>\n","import script from \"./index.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./index.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./index.vue?vue&type=style&index=0&id=e9889a0e&scoped=true&lang=css\"\n\nimport exportComponent from \"/home/runner/work/openlayers/openlayers/node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-e9889a0e\"]])\n\nexport default __exports__","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPoint\n */\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { closestSquaredDistanceXY, containsXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /** @class */ (function (_super) {\n    __extends(MultiPoint, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function MultiPoint(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed point to this multipoint.\n     * @param {Point} point Point.\n     * @api\n     */\n    MultiPoint.prototype.appendPoint = function (point) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = point.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, point.getFlatCoordinates());\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPoint} Clone.\n     * @api\n     */\n    MultiPoint.prototype.clone = function () {\n        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n        multiPoint.applyProperties(this);\n        return multiPoint;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var squaredDistance = squaredDx(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n            if (squaredDistance < minSquaredDistance) {\n                minSquaredDistance = squaredDistance;\n                for (var j = 0; j < stride; ++j) {\n                    closestPoint[j] = flatCoordinates[i + j];\n                }\n                closestPoint.length = stride;\n            }\n        }\n        return minSquaredDistance;\n    };\n    /**\n     * Return the coordinates of the multipoint.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    MultiPoint.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the point at the specified index.\n     * @param {number} index Index.\n     * @return {Point} Point.\n     * @api\n     */\n    MultiPoint.prototype.getPoint = function (index) {\n        var n = !this.flatCoordinates\n            ? 0\n            : this.flatCoordinates.length / this.stride;\n        if (index < 0 || n <= index) {\n            return null;\n        }\n        return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);\n    };\n    /**\n     * Return the points of this multipoint.\n     * @return {Array<Point>} Points.\n     * @api\n     */\n    MultiPoint.prototype.getPoints = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var layout = this.layout;\n        var stride = this.stride;\n        /** @type {Array<Point>} */\n        var points = [];\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n            points.push(point);\n        }\n        return points;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiPoint.prototype.getType = function () {\n        return 'MultiPoint';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPoint.prototype.intersectsExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            if (containsXY(extent, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Set the coordinates of the multipoint.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return MultiPoint;\n}(SimpleGeometry));\nexport default MultiPoint;\n//# sourceMappingURL=MultiPoint.js.map","export * from \"-!../../../../node_modules/.pnpm/mini-css-extract-plugin@0.9.0_webpack@4.47.0/node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../node_modules/.pnpm/css-loader@3.6.0_webpack@4.47.0/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/.pnpm/postcss-loader@3.0.0/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../node_modules/.pnpm/cache-loader@4.1.0_webpack@4.47.0/node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/index.js??ref--1-1!./index.vue?vue&type=style&index=0&id=e9889a0e&scoped=true&lang=css\"","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { createOrUpdate, forEachCorner, intersects } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { rotate, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     *     For internal use, flat coordinates in combination with `opt_layout` and no\n     *     `opt_radius` are also accepted.\n     * @param {number} [opt_radius] Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function Circle(center, opt_radius, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout !== undefined && opt_radius === undefined) {\n            _this.setFlatCoordinates(opt_layout, center);\n        }\n        else {\n            var radius = opt_radius ? opt_radius : 0;\n            _this.setCenterAndRadius(center, radius, opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Circle} Clone.\n     * @api\n     */\n    Circle.prototype.clone = function () {\n        var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n        circle.applyProperties(this);\n        return circle;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        var squaredDistance = dx * dx + dy * dy;\n        if (squaredDistance < minSquaredDistance) {\n            if (squaredDistance === 0) {\n                for (var i = 0; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            else {\n                var delta = this.getRadius() / Math.sqrt(squaredDistance);\n                closestPoint[0] = flatCoordinates[0] + delta * dx;\n                closestPoint[1] = flatCoordinates[1] + delta * dy;\n                for (var i = 2; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            closestPoint.length = this.stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Circle.prototype.containsXY = function (x, y) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        return dx * dx + dy * dy <= this.getRadiusSquared_();\n    };\n    /**\n     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @return {import(\"../coordinate.js\").Coordinate} Center.\n     * @api\n     */\n    Circle.prototype.getCenter = function () {\n        return this.flatCoordinates.slice(0, this.stride);\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Circle.prototype.computeExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n        return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n    };\n    /**\n     * Return the radius of the circle.\n     * @return {number} Radius.\n     * @api\n     */\n    Circle.prototype.getRadius = function () {\n        return Math.sqrt(this.getRadiusSquared_());\n    };\n    /**\n     * @private\n     * @return {number} Radius squared.\n     */\n    Circle.prototype.getRadiusSquared_ = function () {\n        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n        return dx * dx + dy * dy;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    Circle.prototype.getType = function () {\n        return 'Circle';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Circle.prototype.intersectsExtent = function (extent) {\n        var circleExtent = this.getExtent();\n        if (intersects(extent, circleExtent)) {\n            var center = this.getCenter();\n            if (extent[0] <= center[0] && extent[2] >= center[0]) {\n                return true;\n            }\n            if (extent[1] <= center[1] && extent[3] >= center[1]) {\n                return true;\n            }\n            return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n        }\n        return false;\n    };\n    /**\n     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center.\n     * @api\n     */\n    Circle.prototype.setCenter = function (center) {\n        var stride = this.stride;\n        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n        var flatCoordinates = center.slice();\n        flatCoordinates[stride] = flatCoordinates[0] + radius;\n        for (var i = 1; i < stride; ++i) {\n            flatCoordinates[stride + i] = center[i];\n        }\n        this.setFlatCoordinates(this.layout, flatCoordinates);\n        this.changed();\n    };\n    /**\n     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n     * number) of the circle.\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     * @param {number} radius Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {\n        this.setLayout(opt_layout, center, 0);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        /** @type {Array<number>} */\n        var flatCoordinates = this.flatCoordinates;\n        var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n        flatCoordinates[offset++] = flatCoordinates[0] + radius;\n        for (var i = 1, ii = this.stride; i < ii; ++i) {\n            flatCoordinates[offset++] = flatCoordinates[i];\n        }\n        flatCoordinates.length = offset;\n        this.changed();\n    };\n    Circle.prototype.getCoordinates = function () {\n        return null;\n    };\n    Circle.prototype.setCoordinates = function (coordinates, opt_layout) { };\n    /**\n     * Set the radius of the circle. The radius is in the units of the projection.\n     * @param {number} radius Radius.\n     * @api\n     */\n    Circle.prototype.setRadius = function (radius) {\n        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n        this.changed();\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    Circle.prototype.rotate = function (angle, anchor) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(rotate(center, 0, center.length, stride, angle, anchor, center));\n        this.changed();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    Circle.prototype.translate = function (deltaX, deltaY) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));\n        this.changed();\n    };\n    return Circle;\n}(SimpleGeometry));\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n//# sourceMappingURL=Circle.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {\n    var o, t;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n        o = offset;\n    }\n    else if (n === 2) {\n        o = offset;\n        t = fraction;\n    }\n    else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length_1 = 0;\n        var cumulativeLengths = [0];\n        for (var i = offset + stride; i < end; i += stride) {\n            var x2 = flatCoordinates[i];\n            var y2 = flatCoordinates[i + 1];\n            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            cumulativeLengths.push(length_1);\n            x1 = x2;\n            y1 = y2;\n        }\n        var target = fraction * length_1;\n        var index = binarySearch(cumulativeLengths, target);\n        if (index < 0) {\n            t =\n                (target - cumulativeLengths[-index - 2]) /\n                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n            o = offset + (-index - 2) * stride;\n        }\n        else {\n            o = offset + index * stride;\n        }\n    }\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var dest = opt_dest ? opt_dest : new Array(dimension);\n    for (var i = 0; i < dimension; ++i) {\n        dest[i] =\n            o === undefined\n                ? NaN\n                : t === undefined\n                    ? flatCoordinates[o + i]\n                    : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n        return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(offset, offset + stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(end - stride, end);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n        var mid = (lo + hi) >> 1;\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(0, stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        if (offset == end) {\n            continue;\n        }\n        if (m < flatCoordinates[offset + stride - 1]) {\n            return null;\n        }\n        else if (m <= flatCoordinates[end - 1]) {\n            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n        offset = end;\n    }\n    return null;\n}\n//# sourceMappingURL=interpolate.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta, } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray, } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /** @class */ (function (_super) {\n    __extends(MultiPolygon, _super);\n    /**\n     * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.\n     */\n    function MultiPolygon(coordinates, opt_layout, opt_endss) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        _this.endss_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointsRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.flatInteriorPoints_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (!opt_endss && !Array.isArray(coordinates[0])) {\n            var layout = _this.getLayout();\n            var polygons = /** @type {Array<Polygon>} */ (coordinates);\n            var flatCoordinates = [];\n            var endss = [];\n            for (var i = 0, ii = polygons.length; i < ii; ++i) {\n                var polygon = polygons[i];\n                if (i === 0) {\n                    layout = polygon.getLayout();\n                }\n                var offset = flatCoordinates.length;\n                var ends = polygon.getEnds();\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] += offset;\n                }\n                extend(flatCoordinates, polygon.getFlatCoordinates());\n                endss.push(ends);\n            }\n            opt_layout = layout;\n            coordinates = flatCoordinates;\n            opt_endss = endss;\n        }\n        if (opt_layout !== undefined && opt_endss) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.endss_ = opt_endss;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed polygon to this multipolygon.\n     * @param {Polygon} polygon Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.appendPolygon = function (polygon) {\n        /** @type {Array<number>} */\n        var ends;\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = polygon.getFlatCoordinates().slice();\n            ends = polygon.getEnds().slice();\n            this.endss_.push();\n        }\n        else {\n            var offset = this.flatCoordinates.length;\n            extend(this.flatCoordinates, polygon.getFlatCoordinates());\n            ends = polygon.getEnds().slice();\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] += offset;\n            }\n        }\n        this.endss_.push(ends);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPolygon} Clone.\n     * @api\n     */\n    MultiPolygon.prototype.clone = function () {\n        var len = this.endss_.length;\n        var newEndss = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            newEndss[i] = this.endss_[i].slice();\n        }\n        var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n        multiPolygon.applyProperties(this);\n        return multiPolygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    MultiPolygon.prototype.containsXY = function (x, y) {\n        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the multipolygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    MultiPolygon.prototype.getArea = function () {\n        return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for multi-polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n     * @api\n     */\n    MultiPolygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n    };\n    /**\n     * @return {Array<Array<number>>} Endss.\n     */\n    MultiPolygon.prototype.getEndss = function () {\n        return this.endss_;\n    };\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n    MultiPolygon.prototype.getFlatInteriorPoints = function () {\n        if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n            var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n            this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n            this.flatInteriorPointsRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoints_;\n    };\n    /**\n     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n     * @return {MultiPoint} Interior points as XYM coordinates, where M is\n     * the length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    MultiPolygon.prototype.getInteriorPoints = function () {\n        return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    MultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiPolygon} Simplified MultiPolygon.\n     * @protected\n     */\n    MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEndss = [];\n        simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n    };\n    /**\n     * Return the polygon at the specified index.\n     * @param {number} index Index.\n     * @return {Polygon} Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygon = function (index) {\n        if (index < 0 || this.endss_.length <= index) {\n            return null;\n        }\n        var offset;\n        if (index === 0) {\n            offset = 0;\n        }\n        else {\n            var prevEnds = this.endss_[index - 1];\n            offset = prevEnds[prevEnds.length - 1];\n        }\n        var ends = this.endss_[index].slice();\n        var end = ends[ends.length - 1];\n        if (offset !== 0) {\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] -= offset;\n            }\n        }\n        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n    };\n    /**\n     * Return the polygons of this multipolygon.\n     * @return {Array<Polygon>} Polygons.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygons = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var endss = this.endss_;\n        var polygons = [];\n        var offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var ends = endss[i].slice();\n            var end = ends[ends.length - 1];\n            if (offset !== 0) {\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] -= offset;\n                }\n            }\n            var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n            polygons.push(polygon);\n            offset = end;\n        }\n        return polygons;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiPolygon.prototype.getType = function () {\n        return 'MultiPolygon';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPolygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multipolygon.\n     * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 3);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n        if (endss.length === 0) {\n            this.flatCoordinates.length = 0;\n        }\n        else {\n            var lastEnds = endss[endss.length - 1];\n            this.flatCoordinates.length =\n                lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n        }\n        this.changed();\n    };\n    return MultiPolygon;\n}(SimpleGeometry));\nexport default MultiPolygon;\n//# sourceMappingURL=MultiPolygon.js.map","/**\n * @module ol/geom/flat/center\n */\nimport { createEmpty, createOrUpdateFromFlatCoordinates } from '../../extent.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n    var flatCenters = [];\n    var extent = createEmpty();\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n        offset = ends[ends.length - 1];\n    }\n    return flatCenters;\n}\n//# sourceMappingURL=center.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiLineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM, } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /** @class */ (function (_super) {\n    __extends(MultiLineString, _super);\n    /**\n     * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n     *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n     *     combination with `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n     */\n    function MultiLineString(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (Array.isArray(coordinates[0])) {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        else if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            var layout = _this.getLayout();\n            var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n            var flatCoordinates = [];\n            var ends = [];\n            for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n                var lineString = lineStrings[i];\n                if (i === 0) {\n                    layout = lineString.getLayout();\n                }\n                extend(flatCoordinates, lineString.getFlatCoordinates());\n                ends.push(flatCoordinates.length);\n            }\n            _this.setFlatCoordinates(layout, flatCoordinates);\n            _this.ends_ = ends;\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linestring to the multilinestring.\n     * @param {LineString} lineString LineString.\n     * @api\n     */\n    MultiLineString.prototype.appendLineString = function (lineString) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = lineString.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiLineString} Clone.\n     * @api\n     */\n    MultiLineString.prototype.clone = function () {\n        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        multiLineString.applyProperties(this);\n        return multiLineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * `opt_interpolate` controls interpolation between consecutive LineStrings\n     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n     * will be linearly interpolated between the last coordinate of one LineString\n     * and the first coordinate of the next LineString.  If `opt_interpolate` is\n     * `false` then the function will return `null` for Ms falling between\n     * LineStrings.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {\n        if ((this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) ||\n            this.flatCoordinates.length === 0) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n    };\n    /**\n     * Return the coordinates of the multilinestring.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinates = function () {\n        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    MultiLineString.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * Return the linestring at the specified index.\n     * @param {number} index Index.\n     * @return {LineString} LineString.\n     * @api\n     */\n    MultiLineString.prototype.getLineString = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linestrings of this multilinestring.\n     * @return {Array<LineString>} LineStrings.\n     * @api\n     */\n    MultiLineString.prototype.getLineStrings = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var layout = this.layout;\n        /** @type {Array<LineString>} */\n        var lineStrings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n            lineStrings.push(lineString);\n            offset = end;\n        }\n        return lineStrings;\n    };\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n    MultiLineString.prototype.getFlatMidpoints = function () {\n        var midpoints = [];\n        var flatCoordinates = this.flatCoordinates;\n        var offset = 0;\n        var ends = this.ends_;\n        var stride = this.stride;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n            extend(midpoints, midpoint);\n            offset = end;\n        }\n        return midpoints;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiLineString} Simplified MultiLineString.\n     * @protected\n     */\n    MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiLineString.prototype.getType = function () {\n        return 'MultiLineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiLineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multilinestring.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {GeometryLayout} [opt_layout] Layout.\n     * @api\n     */\n    MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return MultiLineString;\n}(SimpleGeometry));\nexport default MultiLineString;\n//# sourceMappingURL=MultiLineString.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { always, noModifierKeys, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight, } from '../extent.js';\nimport { createEditingStyle } from '../style/Style.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\nimport { squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\nvar Mode = {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    POLYGON: 'Polygon',\n    CIRCLE: 'Circle',\n};\n/**\n * @enum {string}\n */\nvar DrawEventType = {\n    /**\n     * Triggered upon feature draw start\n     * @event DrawEvent#drawstart\n     * @api\n     */\n    DRAWSTART: 'drawstart',\n    /**\n     * Triggered upon feature draw end\n     * @event DrawEvent#drawend\n     * @api\n     */\n    DRAWEND: 'drawend',\n    /**\n     * Triggered upon feature draw abortion\n     * @event DrawEvent#drawabort\n     * @api\n     */\n    DRAWABORT: 'drawabort',\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nvar DrawEvent = /** @class */ (function (_super) {\n    __extends(DrawEvent, _super);\n    /**\n     * @param {DrawEventType} type Type.\n     * @param {Feature} feature The feature drawn.\n     */\n    function DrawEvent(type, feature) {\n        var _this = _super.call(this, type) || this;\n        /**\n         * The feature being drawn.\n         * @type {Feature}\n         * @api\n         */\n        _this.feature = feature;\n        return _this;\n    }\n    return DrawEvent;\n}(Event));\nexport { DrawEvent };\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nvar Draw = /** @class */ (function (_super) {\n    __extends(Draw, _super);\n    /**\n     * @param {Options} options Options.\n     */\n    function Draw(options) {\n        var _this = this;\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {DrawOnSignature<void>}\n         */\n        _this.un;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.shouldHandle_ = false;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         * @private\n         */\n        _this.downPx_ = null;\n        /**\n         * @type {?}\n         * @private\n         */\n        _this.downTimeout_;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n        _this.lastDragTime_;\n        /**\n         * Pointer type of the last pointermove event\n         * @type {string}\n         * @private\n         */\n        _this.pointerType_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.freehand_ = false;\n        /**\n         * Target source for drawn features.\n         * @type {VectorSource|null}\n         * @private\n         */\n        _this.source_ = options.source ? options.source : null;\n        /**\n         * Target collection for drawn features.\n         * @type {import(\"../Collection.js\").default<Feature>|null}\n         * @private\n         */\n        _this.features_ = options.features ? options.features : null;\n        /**\n         * Pixel distance for snapping.\n         * @type {number}\n         * @private\n         */\n        _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n        /**\n         * Geometry type.\n         * @type {import(\"../geom/Geometry.js\").Type}\n         * @private\n         */\n        _this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (options.type);\n        /**\n         * Drawing mode (derived from geometry type.\n         * @type {Mode}\n         * @private\n         */\n        _this.mode_ = getMode(_this.type_);\n        /**\n         * Stop click, singleclick, and doubleclick events from firing during drawing.\n         * Default is `false`.\n         * @type {boolean}\n         * @private\n         */\n        _this.stopClick_ = !!options.stopClick;\n        /**\n         * The number of points that must be drawn before a polygon ring or line\n         * string can be finished.  The default is 3 for polygon rings and 2 for\n         * line strings.\n         * @type {number}\n         * @private\n         */\n        _this.minPoints_ = options.minPoints\n            ? options.minPoints\n            : _this.mode_ === Mode.POLYGON\n                ? 3\n                : 2;\n        /**\n         * The number of points that can be drawn before a polygon ring or line string\n         * is finished. The default is no restriction.\n         * @type {number}\n         * @private\n         */\n        _this.maxPoints_ =\n            _this.mode_ === Mode.CIRCLE\n                ? 2\n                : options.maxPoints\n                    ? options.maxPoints\n                    : Infinity;\n        /**\n         * A function to decide if a potential finish coordinate is permissible\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.finishCondition_ = options.finishCondition\n            ? options.finishCondition\n            : TRUE;\n        /**\n         * @private\n         * @type {import(\"../geom/GeometryLayout\").default}\n         */\n        _this.geometryLayout_ = options.geometryLayout\n            ? options.geometryLayout\n            : GeometryLayout.XY;\n        var geometryFunction = options.geometryFunction;\n        if (!geometryFunction) {\n            var mode_1 = _this.mode_;\n            if (mode_1 === Mode.CIRCLE) {\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    var circle = geometry\n                        ? /** @type {Circle} */ (geometry)\n                        : new Circle([NaN, NaN]);\n                    var center = fromUserCoordinate(coordinates[0], projection);\n                    var squaredLength = squaredCoordinateDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));\n                    circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);\n                    var userProjection = getUserProjection();\n                    if (userProjection) {\n                        circle.transform(projection, userProjection);\n                    }\n                    return circle;\n                };\n            }\n            else {\n                var Constructor_1;\n                if (mode_1 === Mode.POINT) {\n                    Constructor_1 = Point;\n                }\n                else if (mode_1 === Mode.LINE_STRING) {\n                    Constructor_1 = LineString;\n                }\n                else if (mode_1 === Mode.POLYGON) {\n                    Constructor_1 = Polygon;\n                }\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    if (geometry) {\n                        if (mode_1 === Mode.POLYGON) {\n                            if (coordinates[0].length) {\n                                // Add a closing coordinate to match the first\n                                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])], this.geometryLayout_);\n                            }\n                            else {\n                                geometry.setCoordinates([], this.geometryLayout_);\n                            }\n                        }\n                        else {\n                            geometry.setCoordinates(coordinates, this.geometryLayout_);\n                        }\n                    }\n                    else {\n                        geometry = new Constructor_1(coordinates, this.geometryLayout_);\n                    }\n                    return geometry;\n                };\n            }\n        }\n        /**\n         * @type {GeometryFunction}\n         * @private\n         */\n        _this.geometryFunction_ = geometryFunction;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.dragVertexDelay_ =\n            options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n        /**\n         * Finish coordinate for the feature (first point for polygons, last point for\n         * linestrings).\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.finishCoordinate_ = null;\n        /**\n         * Sketch feature.\n         * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n         * @private\n         */\n        _this.sketchFeature_ = null;\n        /**\n         * Sketch point.\n         * @type {Feature<Point>}\n         * @private\n         */\n        _this.sketchPoint_ = null;\n        /**\n         * Sketch coordinates. Used when drawing a line or polygon.\n         * @type {SketchCoordType}\n         * @private\n         */\n        _this.sketchCoords_ = null;\n        /**\n         * Sketch line. Used when drawing polygon.\n         * @type {Feature<LineString>}\n         * @private\n         */\n        _this.sketchLine_ = null;\n        /**\n         * Sketch line coordinates. Used when drawing a polygon or circle.\n         * @type {LineCoordType}\n         * @private\n         */\n        _this.sketchLineCoords_ = null;\n        /**\n         * Squared tolerance for handling up events.  If the squared distance\n         * between a down and up event is greater than this tolerance, up events\n         * will not be handled.\n         * @type {number}\n         * @private\n         */\n        _this.squaredClickTolerance_ = options.clickTolerance\n            ? options.clickTolerance * options.clickTolerance\n            : 36;\n        /**\n         * Draw overlay where our sketch features are drawn.\n         * @type {VectorLayer}\n         * @private\n         */\n        _this.overlay_ = new VectorLayer({\n            source: new VectorSource({\n                useSpatialIndex: false,\n                wrapX: options.wrapX ? options.wrapX : false,\n            }),\n            style: options.style ? options.style : getDefaultStyleFunction(),\n            updateWhileInteracting: true,\n        });\n        /**\n         * Name of the geometry attribute for newly created features.\n         * @type {string|undefined}\n         * @private\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.condition_ = options.condition ? options.condition : noModifierKeys;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.freehandCondition_;\n        if (options.freehand) {\n            _this.freehandCondition_ = always;\n        }\n        else {\n            _this.freehandCondition_ = options.freehandCondition\n                ? options.freehandCondition\n                : shiftKeyOnly;\n        }\n        _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);\n        return _this;\n    }\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    Draw.prototype.setMap = function (map) {\n        _super.prototype.setMap.call(this, map);\n        this.updateState_();\n    };\n    /**\n     * Get the overlay layer that this interaction renders sketch features to.\n     * @return {VectorLayer} Overlay layer.\n     * @api\n     */\n    Draw.prototype.getOverlay = function () {\n        return this.overlay_;\n    };\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @api\n     */\n    Draw.prototype.handleEvent = function (event) {\n        if (event.originalEvent.type === EventType.CONTEXTMENU) {\n            // Avoid context menu for long taps when drawing on mobile\n            event.originalEvent.preventDefault();\n        }\n        this.freehand_ =\n            this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n        var move = event.type === MapBrowserEventType.POINTERMOVE;\n        var pass = true;\n        if (!this.freehand_ &&\n            this.lastDragTime_ &&\n            event.type === MapBrowserEventType.POINTERDRAG) {\n            var now = Date.now();\n            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n                this.downPx_ = event.pixel;\n                this.shouldHandle_ = !this.freehand_;\n                move = true;\n            }\n            else {\n                this.lastDragTime_ = undefined;\n            }\n            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n        }\n        if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDRAG &&\n            this.sketchFeature_ !== null) {\n            this.addToDrawing_(event.coordinate);\n            pass = false;\n        }\n        else if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDOWN) {\n            pass = false;\n        }\n        else if (move && this.getPointerCount() < 2) {\n            pass = event.type === MapBrowserEventType.POINTERMOVE;\n            if (pass && this.freehand_) {\n                this.handlePointerMove_(event);\n                if (this.shouldHandle_) {\n                    // Avoid page scrolling when freehand drawing on mobile\n                    event.originalEvent.preventDefault();\n                }\n            }\n            else if (event.originalEvent.pointerType === 'mouse' ||\n                (event.type === MapBrowserEventType.POINTERDRAG &&\n                    this.downTimeout_ === undefined)) {\n                this.handlePointerMove_(event);\n            }\n        }\n        else if (event.type === MapBrowserEventType.DBLCLICK) {\n            pass = false;\n        }\n        return _super.prototype.handleEvent.call(this, event) && pass;\n    };\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleDownEvent = function (event) {\n        this.shouldHandle_ = !this.freehand_;\n        if (this.freehand_) {\n            this.downPx_ = event.pixel;\n            if (!this.finishCoordinate_) {\n                this.startDrawing_(event.coordinate);\n            }\n            return true;\n        }\n        else if (this.condition_(event)) {\n            this.lastDragTime_ = Date.now();\n            this.downTimeout_ = setTimeout(function () {\n                this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n            }.bind(this), this.dragVertexDelay_);\n            this.downPx_ = event.pixel;\n            return true;\n        }\n        else {\n            this.lastDragTime_ = undefined;\n            return false;\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleUpEvent = function (event) {\n        var pass = true;\n        if (this.getPointerCount() === 0) {\n            if (this.downTimeout_) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n            this.handlePointerMove_(event);\n            if (this.shouldHandle_) {\n                var startingToDraw = !this.finishCoordinate_;\n                if (startingToDraw) {\n                    this.startDrawing_(event.coordinate);\n                }\n                if (!startingToDraw && this.freehand_) {\n                    this.finishDrawing();\n                }\n                else if (!this.freehand_ &&\n                    (!startingToDraw || this.mode_ === Mode.POINT)) {\n                    if (this.atFinish_(event.pixel)) {\n                        if (this.finishCondition_(event)) {\n                            this.finishDrawing();\n                        }\n                    }\n                    else {\n                        this.addToDrawing_(event.coordinate);\n                    }\n                }\n                pass = false;\n            }\n            else if (this.freehand_) {\n                this.abortDrawing();\n            }\n        }\n        if (!pass && this.stopClick_) {\n            event.preventDefault();\n        }\n        return pass;\n    };\n    /**\n     * Handle move events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n     * @private\n     */\n    Draw.prototype.handlePointerMove_ = function (event) {\n        this.pointerType_ = event.originalEvent.pointerType;\n        if (this.downPx_ &&\n            ((!this.freehand_ && this.shouldHandle_) ||\n                (this.freehand_ && !this.shouldHandle_))) {\n            var downPx = this.downPx_;\n            var clickPx = event.pixel;\n            var dx = downPx[0] - clickPx[0];\n            var dy = downPx[1] - clickPx[1];\n            var squaredDistance = dx * dx + dy * dy;\n            this.shouldHandle_ = this.freehand_\n                ? squaredDistance > this.squaredClickTolerance_\n                : squaredDistance <= this.squaredClickTolerance_;\n            if (!this.shouldHandle_) {\n                return;\n            }\n        }\n        if (this.finishCoordinate_) {\n            this.modifyDrawing_(event.coordinate);\n        }\n        else {\n            this.createOrUpdateSketchPoint_(event.coordinate.slice());\n        }\n    };\n    /**\n     * Determine if an event is within the snapping tolerance of the start coord.\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @return {boolean} The event is within the snapping tolerance of the start.\n     * @private\n     */\n    Draw.prototype.atFinish_ = function (pixel) {\n        var at = false;\n        if (this.sketchFeature_) {\n            var potentiallyDone = false;\n            var potentiallyFinishCoordinates = [this.finishCoordinate_];\n            var mode = this.mode_;\n            if (mode === Mode.POINT) {\n                at = true;\n            }\n            else if (mode === Mode.CIRCLE) {\n                at = this.sketchCoords_.length === 2;\n            }\n            else if (mode === Mode.LINE_STRING) {\n                potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n            }\n            else if (mode === Mode.POLYGON) {\n                var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n                potentiallyDone = sketchCoords[0].length > this.minPoints_;\n                potentiallyFinishCoordinates = [\n                    sketchCoords[0][0],\n                    sketchCoords[0][sketchCoords[0].length - 2],\n                ];\n            }\n            if (potentiallyDone) {\n                var map = this.getMap();\n                for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n                    var finishCoordinate = potentiallyFinishCoordinates[i];\n                    var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n                    var dx = pixel[0] - finishPixel[0];\n                    var dy = pixel[1] - finishPixel[1];\n                    var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n                    if (at) {\n                        this.finishCoordinate_ = finishCoordinate;\n                        break;\n                    }\n                }\n            }\n        }\n        return at;\n    };\n    /**\n     * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n     * @private\n     */\n    Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {\n        if (!this.sketchPoint_) {\n            this.sketchPoint_ = new Feature(new Point(coordinates));\n            this.updateSketchFeatures_();\n        }\n        else {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinates);\n        }\n    };\n    /**\n     * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n     * @private\n     */\n    Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {\n        if (!this.sketchLine_) {\n            this.sketchLine_ = new Feature();\n        }\n        var ring = geometry.getLinearRing(0);\n        var sketchLineGeom = this.sketchLine_.getGeometry();\n        if (!sketchLineGeom) {\n            sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n            this.sketchLine_.setGeometry(sketchLineGeom);\n        }\n        else {\n            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n            sketchLineGeom.changed();\n        }\n    };\n    /**\n     * Start the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n     * @private\n     */\n    Draw.prototype.startDrawing_ = function (start) {\n        var projection = this.getMap().getView().getProjection();\n        var stride = getStrideForLayout(this.geometryLayout_);\n        while (start.length < stride) {\n            start.push(0);\n        }\n        this.finishCoordinate_ = start;\n        if (this.mode_ === Mode.POINT) {\n            this.sketchCoords_ = start.slice();\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            this.sketchCoords_ = [[start.slice(), start.slice()]];\n            this.sketchLineCoords_ = this.sketchCoords_[0];\n        }\n        else {\n            this.sketchCoords_ = [start.slice(), start.slice()];\n        }\n        if (this.sketchLineCoords_) {\n            this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n        }\n        var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);\n        this.sketchFeature_ = new Feature();\n        if (this.geometryName_) {\n            this.sketchFeature_.setGeometryName(this.geometryName_);\n        }\n        this.sketchFeature_.setGeometry(geometry);\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Modify the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @private\n     */\n    Draw.prototype.modifyDrawing_ = function (coordinate) {\n        var map = this.getMap();\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = map.getView().getProjection();\n        var stride = getStrideForLayout(this.geometryLayout_);\n        var coordinates, last;\n        while (coordinate.length < stride) {\n            coordinate.push(0);\n        }\n        if (this.mode_ === Mode.POINT) {\n            last = this.sketchCoords_;\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            last = coordinates[coordinates.length - 1];\n            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n                // snap to finish\n                coordinate = this.finishCoordinate_.slice();\n            }\n        }\n        else {\n            coordinates = this.sketchCoords_;\n            last = coordinates[coordinates.length - 1];\n        }\n        last[0] = coordinate[0];\n        last[1] = coordinate[1];\n        this.geometryFunction_(\n        /** @type {!LineCoordType} */ (this.sketchCoords_), geometry, projection);\n        if (this.sketchPoint_) {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinate);\n        }\n        if (geometry.getType() === 'Polygon' && this.mode_ !== Mode.POLYGON) {\n            this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n        }\n        else if (this.sketchLineCoords_) {\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Add a new coordinate to the drawing.\n     * @param {!PointCoordType} coordinate Coordinate\n     * @private\n     */\n    Draw.prototype.addToDrawing_ = function (coordinate) {\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var done;\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            this.finishCoordinate_ = coordinate.slice();\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            if (done) {\n                this.finishCoordinate_ = coordinates[0];\n            }\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        this.createOrUpdateSketchPoint_(coordinate.slice());\n        this.updateSketchFeatures_();\n        if (done) {\n            this.finishDrawing();\n        }\n    };\n    /**\n     * Remove last point of the feature currently being drawn. Does not do anything when\n     * drawing POINT or MULTI_POINT geometries.\n     * @api\n     */\n    Draw.prototype.removeLastPoint = function () {\n        if (!this.sketchFeature_) {\n            return;\n        }\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            coordinates.splice(-2, 1);\n            if (coordinates.length >= 2) {\n                this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n                var finishCoordinate = this.finishCoordinate_.slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            this.geometryFunction_(coordinates, geometry, projection);\n            if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n                this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n            }\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            coordinates.splice(-2, 1);\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            if (coordinates.length >= 2) {\n                var finishCoordinate = coordinates[coordinates.length - 2].slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            sketchLineGeom.setCoordinates(coordinates);\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        if (coordinates.length === 1) {\n            this.abortDrawing();\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Stop drawing and add the sketch feature to the target layer.\n     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n     * dispatched before inserting the feature.\n     * @api\n     */\n    Draw.prototype.finishDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (!sketchFeature) {\n            return;\n        }\n        var coordinates = this.sketchCoords_;\n        var geometry = sketchFeature.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        if (this.mode_ === Mode.LINE_STRING) {\n            // remove the redundant last point\n            coordinates.pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            // remove the redundant last point in ring\n            /** @type {PolyCoordType} */ (coordinates)[0].pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n            coordinates = geometry.getCoordinates();\n        }\n        // cast multi-part geometries\n        if (this.type_ === 'MultiPoint') {\n            sketchFeature.setGeometry(new MultiPoint([/** @type {PointCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === 'MultiLineString') {\n            sketchFeature.setGeometry(new MultiLineString([/** @type {LineCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === 'MultiPolygon') {\n            sketchFeature.setGeometry(new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]));\n        }\n        // First dispatch event to allow full set up of feature\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n        // Then insert feature\n        if (this.features_) {\n            this.features_.push(sketchFeature);\n        }\n        if (this.source_) {\n            this.source_.addFeature(sketchFeature);\n        }\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n     * @private\n     */\n    Draw.prototype.abortDrawing_ = function () {\n        this.finishCoordinate_ = null;\n        var sketchFeature = this.sketchFeature_;\n        this.sketchFeature_ = null;\n        this.sketchPoint_ = null;\n        this.sketchLine_ = null;\n        this.overlay_.getSource().clear(true);\n        return sketchFeature;\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @api\n     */\n    Draw.prototype.abortDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (sketchFeature) {\n            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n        }\n    };\n    /**\n     * Append coordinates to the end of the geometry that is currently being drawn.\n     * This can be used when drawing LineStrings or Polygons. Coordinates will\n     * either be appended to the current LineString or the outer ring of the current\n     * Polygon. If no geometry is being drawn, a new one will be created.\n     * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n     * the coordinate array.\n     * @api\n     */\n    Draw.prototype.appendCoordinates = function (coordinates) {\n        var mode = this.mode_;\n        var newDrawing = !this.sketchFeature_;\n        if (newDrawing) {\n            this.startDrawing_(coordinates[0]);\n        }\n        /** @type {LineCoordType} */\n        var sketchCoords;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n        }\n        else if (mode === Mode.POLYGON) {\n            sketchCoords =\n                this.sketchCoords_ && this.sketchCoords_.length\n                    ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n                    : [];\n        }\n        else {\n            return;\n        }\n        if (newDrawing) {\n            sketchCoords.shift();\n        }\n        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n        sketchCoords.pop();\n        // Append coordinate list\n        for (var i = 0; i < coordinates.length; i++) {\n            this.addToDrawing_(coordinates[i]);\n        }\n        var ending = coordinates[coordinates.length - 1];\n        // Duplicate last coordinate for sketch drawing (cursor position)\n        this.addToDrawing_(ending);\n        this.modifyDrawing_(ending);\n    };\n    /**\n     * Initiate draw mode by starting from an existing geometry which will\n     * receive new additional points. This only works on features with\n     * `LineString` geometries, where the interaction will extend lines by adding\n     * points to the end of the coordinates array.\n     * This will change the original feature, instead of drawing a copy.\n     *\n     * The function will dispatch a `drawstart` event.\n     *\n     * @param {!Feature<LineString>} feature Feature to be extended.\n     * @api\n     */\n    Draw.prototype.extend = function (feature) {\n        var geometry = feature.getGeometry();\n        var lineString = geometry;\n        this.sketchFeature_ = feature;\n        this.sketchCoords_ = lineString.getCoordinates();\n        var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n        this.finishCoordinate_ = last.slice();\n        this.sketchCoords_.push(last.slice());\n        this.sketchPoint_ = new Feature(new Point(last));\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Redraw the sketch features.\n     * @private\n     */\n    Draw.prototype.updateSketchFeatures_ = function () {\n        var sketchFeatures = [];\n        if (this.sketchFeature_) {\n            sketchFeatures.push(this.sketchFeature_);\n        }\n        if (this.sketchLine_) {\n            sketchFeatures.push(this.sketchLine_);\n        }\n        if (this.sketchPoint_) {\n            sketchFeatures.push(this.sketchPoint_);\n        }\n        var overlaySource = this.overlay_.getSource();\n        overlaySource.clear(true);\n        overlaySource.addFeatures(sketchFeatures);\n    };\n    /**\n     * @private\n     */\n    Draw.prototype.updateState_ = function () {\n        var map = this.getMap();\n        var active = this.getActive();\n        if (!map || !active) {\n            this.abortDrawing();\n        }\n        this.overlay_.setMap(active ? map : null);\n    };\n    return Draw;\n}(PointerInteraction));\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n    var styles = createEditingStyle();\n    return function (feature, resolution) {\n        return styles[feature.getGeometry().getType()];\n    };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [opt_sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [opt_angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(opt_sides, opt_angle) {\n    return function (coordinates, opt_geometry, projection) {\n        var center = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[0], projection);\n        var end = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1], projection);\n        var radius = Math.sqrt(squaredCoordinateDistance(center, end));\n        var geometry = opt_geometry\n            ? /** @type {Polygon} */ (opt_geometry)\n            : fromCircle(new Circle(center), opt_sides);\n        var angle = opt_angle;\n        if (!opt_angle && opt_angle !== 0) {\n            var x = end[0] - center[0];\n            var y = end[1] - center[1];\n            angle = Math.atan2(y, x);\n        }\n        makeRegular(geometry, center, radius, angle);\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n    return function (coordinates, opt_geometry, projection) {\n        var extent = boundingExtent(\n        /** @type {LineCoordType} */ ([\n            coordinates[0],\n            coordinates[coordinates.length - 1],\n        ]).map(function (coordinate) {\n            return fromUserCoordinate(coordinate, projection);\n        }));\n        var boxCoordinates = [\n            [\n                getBottomLeft(extent),\n                getBottomRight(extent),\n                getTopRight(extent),\n                getTopLeft(extent),\n                getBottomLeft(extent),\n            ],\n        ];\n        var geometry = opt_geometry;\n        if (geometry) {\n            geometry.setCoordinates(boxCoordinates);\n        }\n        else {\n            geometry = new Polygon(boxCoordinates);\n        }\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n    switch (type) {\n        case 'Point':\n        case 'MultiPoint':\n            return Mode.POINT;\n        case 'LineString':\n        case 'MultiLineString':\n            return Mode.LINE_STRING;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return Mode.POLYGON;\n        case 'Circle':\n            return Mode.CIRCLE;\n        default:\n            throw new Error('Invalid type: ' + type);\n    }\n}\nexport default Draw;\n//# sourceMappingURL=Draw.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { forEach as forEachSegment } from './flat/segments.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { interpolatePoint, lineStringCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineString } from './flat/intersectsextent.js';\nimport { lineStringLength } from './flat/length.js';\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /** @class */ (function (_super) {\n    __extends(LineString, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function LineString(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatMidpoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatMidpointRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed coordinate to the coordinates of the linestring.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @api\n     */\n    LineString.prototype.appendCoordinate = function (coordinate) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = coordinate.slice();\n        }\n        else {\n            extend(this.flatCoordinates, coordinate);\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LineString} Clone.\n     * @api\n     */\n    LineString.prototype.clone = function () {\n        var lineString = new LineString(this.flatCoordinates.slice(), this.layout);\n        lineString.applyProperties(this);\n        return lineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Iterate over each segment, calling the provided callback.\n     * If the callback returns a truthy value the function returns that\n     * value immediately. Otherwise the function returns `false`.\n     *\n     * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n     * @return {T|boolean} Value.\n     * @template T,S\n     * @api\n     */\n    LineString.prototype.forEachSegment = function (callback) {\n        return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {\n        if (this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n    };\n    /**\n     * Return the coordinates of the linestring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LineString.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinate at the provided fraction along the linestring.\n     * The `fraction` is a number between 0 and 1, where 0 is the start of the\n     * linestring and 1 is the end.\n     * @param {number} fraction Fraction.\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_dest] Optional coordinate whose values will\n     *     be modified. If not provided, a new coordinate will be returned.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n     * @api\n     */\n    LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {\n        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);\n    };\n    /**\n     * Return the length of the linestring on projected plane.\n     * @return {number} Length (on projected plane).\n     * @api\n     */\n    LineString.prototype.getLength = function () {\n        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat midpoint.\n     */\n    LineString.prototype.getFlatMidpoint = function () {\n        if (this.flatMidpointRevision_ != this.getRevision()) {\n            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n            this.flatMidpointRevision_ = this.getRevision();\n        }\n        return this.flatMidpoint_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} Simplified LineString.\n     * @protected\n     */\n    LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    LineString.prototype.getType = function () {\n        return 'LineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the linestring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    LineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LineString;\n}(SimpleGeometry));\nexport default LineString;\n//# sourceMappingURL=LineString.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/Overlay\n */\nimport BaseObject from './Object.js';\nimport MapEventType from './MapEventType.js';\nimport { CLASS_SELECTABLE } from './css.js';\nimport { containsExtent } from './extent.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { outerHeight, outerWidth, removeChildren, removeNode } from './dom.js';\n/**\n * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning\n * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, or `'top-right'`.\n */\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {Positioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling\n * `setPosition`, so that the overlay is entirely visible in the current viewport?\n * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be\n * used to determine the panning parameters; if an object is supplied then other\n * parameters are ignored.\n * @property {PanOptions} [autoPanAnimation] The animation options used to pan\n * the overlay into view. This animation is only used when `autoPan` is enabled.\n * A `duration` and `easing` may be provided to customize the animation.\n * Deprecated and ignored if `autoPan` is supplied as an object.\n * @property {number} [autoPanMargin=20] The margin (in pixels) between the\n * overlay and the borders of the map when autopanning. Deprecated and ignored\n * if `autoPan` is supplied as an object.\n * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the\n * autoPan. This is only used when `autoPan` is enabled and has preference over\n * the individual `autoPanMargin` and `autoPanOptions`.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing.inAndOut}.\n */\n/**\n * @typedef {Object} PanIntoViewOptions\n * @property {PanOptions} [animation={}] The animation parameters for the pan\n * @property {number} [margin=20] The margin (in pixels) between the\n * overlay and the borders of the map when panning into view.\n */\n/**\n * @enum {string}\n * @protected\n */\nvar Property = {\n    ELEMENT: 'element',\n    MAP: 'map',\n    OFFSET: 'offset',\n    POSITION: 'position',\n    POSITIONING: 'positioning',\n};\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:element'|'change:map'|'change:offset'|'change:position'|\n *   'change:positioning'} OverlayObjectEventTypes\n */\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<OverlayObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature\n */\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay';\n *\n *     var popup = new Overlay({\n *       element: document.getElementById('popup')\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\nvar Overlay = /** @class */ (function (_super) {\n    __extends(Overlay, _super);\n    /**\n     * @param {Options} options Overlay options.\n     */\n    function Overlay(options) {\n        var _this = _super.call(this) || this;\n        /***\n         * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {OverlayOnSignature<void>}\n         */\n        _this.un;\n        /**\n         * @protected\n         * @type {Options}\n         */\n        _this.options = options;\n        /**\n         * @protected\n         * @type {number|string|undefined}\n         */\n        _this.id = options.id;\n        /**\n         * @protected\n         * @type {boolean}\n         */\n        _this.insertFirst =\n            options.insertFirst !== undefined ? options.insertFirst : true;\n        /**\n         * @protected\n         * @type {boolean}\n         */\n        _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n        /**\n         * @protected\n         * @type {HTMLElement}\n         */\n        _this.element = document.createElement('div');\n        _this.element.className =\n            options.className !== undefined\n                ? options.className\n                : 'ol-overlay-container ' + CLASS_SELECTABLE;\n        _this.element.style.position = 'absolute';\n        _this.element.style.pointerEvents = 'auto';\n        var autoPan = options.autoPan;\n        if (autoPan && 'object' !== typeof autoPan) {\n            autoPan = {\n                animation: options.autoPanAnimation,\n                margin: options.autoPanMargin,\n            };\n        }\n        /**\n         * @protected\n         * @type {PanIntoViewOptions|false}\n         */\n        _this.autoPan = /** @type {PanIntoViewOptions} */ (autoPan) || false;\n        /**\n         * @protected\n         * @type {{transform_: string,\n         *         visible: boolean}}\n         */\n        _this.rendered = {\n            transform_: '',\n            visible: true,\n        };\n        /**\n         * @protected\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n        _this.mapPostrenderListenerKey = null;\n        _this.addChangeListener(Property.ELEMENT, _this.handleElementChanged);\n        _this.addChangeListener(Property.MAP, _this.handleMapChanged);\n        _this.addChangeListener(Property.OFFSET, _this.handleOffsetChanged);\n        _this.addChangeListener(Property.POSITION, _this.handlePositionChanged);\n        _this.addChangeListener(Property.POSITIONING, _this.handlePositioningChanged);\n        if (options.element !== undefined) {\n            _this.setElement(options.element);\n        }\n        _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n        _this.setPositioning(options.positioning || 'top-left');\n        if (options.position !== undefined) {\n            _this.setPosition(options.position);\n        }\n        return _this;\n    }\n    /**\n     * Get the DOM element of this overlay.\n     * @return {HTMLElement|undefined} The Element containing the overlay.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.getElement = function () {\n        return /** @type {HTMLElement|undefined} */ (this.get(Property.ELEMENT));\n    };\n    /**\n     * Get the overlay identifier which is set on constructor.\n     * @return {number|string|undefined} Id.\n     * @api\n     */\n    Overlay.prototype.getId = function () {\n        return this.id;\n    };\n    /**\n     * Get the map associated with this overlay.\n     * @return {import(\"./PluggableMap.js\").default|null} The map that the\n     * overlay is part of.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.getMap = function () {\n        return /** @type {import(\"./PluggableMap.js\").default|null} */ (this.get(Property.MAP) || null);\n    };\n    /**\n     * Get the offset of this overlay.\n     * @return {Array<number>} The offset.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.getOffset = function () {\n        return /** @type {Array<number>} */ (this.get(Property.OFFSET));\n    };\n    /**\n     * Get the current position of this overlay.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n     *     anchored at.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.getPosition = function () {\n        return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (this.get(Property.POSITION));\n    };\n    /**\n     * Get the current positioning of this overlay.\n     * @return {Positioning} How the overlay is positioned\n     *     relative to its point on the map.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.getPositioning = function () {\n        return /** @type {Positioning} */ (this.get(Property.POSITIONING));\n    };\n    /**\n     * @protected\n     */\n    Overlay.prototype.handleElementChanged = function () {\n        removeChildren(this.element);\n        var element = this.getElement();\n        if (element) {\n            this.element.appendChild(element);\n        }\n    };\n    /**\n     * @protected\n     */\n    Overlay.prototype.handleMapChanged = function () {\n        if (this.mapPostrenderListenerKey) {\n            removeNode(this.element);\n            unlistenByKey(this.mapPostrenderListenerKey);\n            this.mapPostrenderListenerKey = null;\n        }\n        var map = this.getMap();\n        if (map) {\n            this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);\n            this.updatePixelPosition();\n            var container = this.stopEvent\n                ? map.getOverlayContainerStopEvent()\n                : map.getOverlayContainer();\n            if (this.insertFirst) {\n                container.insertBefore(this.element, container.childNodes[0] || null);\n            }\n            else {\n                container.appendChild(this.element);\n            }\n            this.performAutoPan();\n        }\n    };\n    /**\n     * @protected\n     */\n    Overlay.prototype.render = function () {\n        this.updatePixelPosition();\n    };\n    /**\n     * @protected\n     */\n    Overlay.prototype.handleOffsetChanged = function () {\n        this.updatePixelPosition();\n    };\n    /**\n     * @protected\n     */\n    Overlay.prototype.handlePositionChanged = function () {\n        this.updatePixelPosition();\n        this.performAutoPan();\n    };\n    /**\n     * @protected\n     */\n    Overlay.prototype.handlePositioningChanged = function () {\n        this.updatePixelPosition();\n    };\n    /**\n     * Set the DOM element to be associated with this overlay.\n     * @param {HTMLElement|undefined} element The Element containing the overlay.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.setElement = function (element) {\n        this.set(Property.ELEMENT, element);\n    };\n    /**\n     * Set the map to be associated with this overlay.\n     * @param {import(\"./PluggableMap.js\").default|null} map The map that the\n     * overlay is part of. Pass `null` to just remove the overlay from the current map.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.setMap = function (map) {\n        this.set(Property.MAP, map);\n    };\n    /**\n     * Set the offset for this overlay.\n     * @param {Array<number>} offset Offset.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.setOffset = function (offset) {\n        this.set(Property.OFFSET, offset);\n    };\n    /**\n     * Set the position for this overlay. If the position is `undefined` the\n     * overlay is hidden.\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n     *     is anchored at.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.setPosition = function (position) {\n        this.set(Property.POSITION, position);\n    };\n    /**\n     * Pan the map so that the overlay is entirely visible in the current viewport\n     * (if necessary) using the configured autoPan parameters\n     * @protected\n     */\n    Overlay.prototype.performAutoPan = function () {\n        if (this.autoPan) {\n            this.panIntoView(this.autoPan);\n        }\n    };\n    /**\n     * Pan the map so that the overlay is entirely visible in the current viewport\n     * (if necessary).\n     * @param {PanIntoViewOptions} [opt_panIntoViewOptions] Options for the pan action\n     * @api\n     */\n    Overlay.prototype.panIntoView = function (opt_panIntoViewOptions) {\n        var map = this.getMap();\n        if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {\n            return;\n        }\n        var mapRect = this.getRect(map.getTargetElement(), map.getSize());\n        var element = this.getElement();\n        var overlayRect = this.getRect(element, [\n            outerWidth(element),\n            outerHeight(element),\n        ]);\n        var panIntoViewOptions = opt_panIntoViewOptions || {};\n        var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;\n        if (!containsExtent(mapRect, overlayRect)) {\n            // the overlay is not completely inside the viewport, so pan the map\n            var offsetLeft = overlayRect[0] - mapRect[0];\n            var offsetRight = mapRect[2] - overlayRect[2];\n            var offsetTop = overlayRect[1] - mapRect[1];\n            var offsetBottom = mapRect[3] - overlayRect[3];\n            var delta = [0, 0];\n            if (offsetLeft < 0) {\n                // move map to the left\n                delta[0] = offsetLeft - myMargin;\n            }\n            else if (offsetRight < 0) {\n                // move map to the right\n                delta[0] = Math.abs(offsetRight) + myMargin;\n            }\n            if (offsetTop < 0) {\n                // move map up\n                delta[1] = offsetTop - myMargin;\n            }\n            else if (offsetBottom < 0) {\n                // move map down\n                delta[1] = Math.abs(offsetBottom) + myMargin;\n            }\n            if (delta[0] !== 0 || delta[1] !== 0) {\n                var center = /** @type {import(\"./coordinate.js\").Coordinate} */ (map.getView().getCenterInternal());\n                var centerPx = map.getPixelFromCoordinateInternal(center);\n                if (!centerPx) {\n                    return;\n                }\n                var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n                var panOptions = panIntoViewOptions.animation || {};\n                map.getView().animateInternal({\n                    center: map.getCoordinateFromPixelInternal(newCenterPx),\n                    duration: panOptions.duration,\n                    easing: panOptions.easing,\n                });\n            }\n        }\n    };\n    /**\n     * Get the extent of an element relative to the document\n     * @param {HTMLElement} element The element.\n     * @param {import(\"./size.js\").Size} size The size of the element.\n     * @return {import(\"./extent.js\").Extent} The extent.\n     * @protected\n     */\n    Overlay.prototype.getRect = function (element, size) {\n        var box = element.getBoundingClientRect();\n        var offsetX = box.left + window.pageXOffset;\n        var offsetY = box.top + window.pageYOffset;\n        return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n    };\n    /**\n     * Set the positioning for this overlay.\n     * @param {Positioning} positioning how the overlay is\n     *     positioned relative to its point on the map.\n     * @observable\n     * @api\n     */\n    Overlay.prototype.setPositioning = function (positioning) {\n        this.set(Property.POSITIONING, positioning);\n    };\n    /**\n     * Modify the visibility of the element.\n     * @param {boolean} visible Element visibility.\n     * @protected\n     */\n    Overlay.prototype.setVisible = function (visible) {\n        if (this.rendered.visible !== visible) {\n            this.element.style.display = visible ? '' : 'none';\n            this.rendered.visible = visible;\n        }\n    };\n    /**\n     * Update pixel position.\n     * @protected\n     */\n    Overlay.prototype.updatePixelPosition = function () {\n        var map = this.getMap();\n        var position = this.getPosition();\n        if (!map || !map.isRendered() || !position) {\n            this.setVisible(false);\n            return;\n        }\n        var pixel = map.getPixelFromCoordinate(position);\n        var mapSize = map.getSize();\n        this.updateRenderedPosition(pixel, mapSize);\n    };\n    /**\n     * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n     * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n     * @protected\n     */\n    Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {\n        var style = this.element.style;\n        var offset = this.getOffset();\n        var positioning = this.getPositioning();\n        this.setVisible(true);\n        var x = Math.round(pixel[0] + offset[0]) + 'px';\n        var y = Math.round(pixel[1] + offset[1]) + 'px';\n        var posX = '0%';\n        var posY = '0%';\n        if (positioning == 'bottom-right' ||\n            positioning == 'center-right' ||\n            positioning == 'top-right') {\n            posX = '-100%';\n        }\n        else if (positioning == 'bottom-center' ||\n            positioning == 'center-center' ||\n            positioning == 'top-center') {\n            posX = '-50%';\n        }\n        if (positioning == 'bottom-left' ||\n            positioning == 'bottom-center' ||\n            positioning == 'bottom-right') {\n            posY = '-100%';\n        }\n        else if (positioning == 'center-left' ||\n            positioning == 'center-center' ||\n            positioning == 'center-right') {\n            posY = '-50%';\n        }\n        var transform = \"translate(\".concat(posX, \", \").concat(posY, \") translate(\").concat(x, \", \").concat(y, \")\");\n        if (this.rendered.transform_ != transform) {\n            this.rendered.transform_ = transform;\n            style.transform = transform;\n            // @ts-ignore IE9\n            style.msTransform = transform;\n        }\n    };\n    /**\n     * returns the options this Overlay has been created with\n     * @return {Options} overlay options\n     */\n    Overlay.prototype.getOptions = function () {\n        return this.options;\n    };\n    return Overlay;\n}(BaseObject));\nexport default Overlay;\n//# sourceMappingURL=Overlay.js.map"],"sourceRoot":""}