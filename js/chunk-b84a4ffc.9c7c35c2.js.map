{"version":3,"sources":["webpack:///./src/hooks/updateMapSize.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/MultiPoint.js","webpack:///./src/views/drawing/draw-features/index.vue?9ad8","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/Circle.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/flat/interpolate.js","webpack:///./src/views/drawing/draw-features/index.vue","webpack:///./src/views/drawing/draw-features/index.vue?9c68","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/MultiPolygon.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/flat/center.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/MultiLineString.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/interaction/Draw.js","webpack:///./node_modules/.pnpm/ol@6.15.1/node_modules/ol/geom/LineString.js"],"names":["map","targetNode","document","querySelector","observer","MutationObserver","mutationsList","mutation","type","attributeName","i","length","updateSize","observe","attributes","childList","subtree","onBeforeUnmount","disconnect","extendStatics","__extends","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","MultiPoint","_super","coordinates","opt_layout","_this","isArray","setFlatCoordinates","setCoordinates","appendPoint","point","flatCoordinates","getFlatCoordinates","slice","changed","clone","multiPoint","layout","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","stride","ii","squaredDistance","j","getCoordinates","getPoint","index","n","getPoints","points","push","getType","intersectsExtent","extent","setLayout","Circle","center","opt_radius","undefined","radius","setCenterAndRadius","circle","dx","dy","delta","getRadius","Math","sqrt","containsXY","getRadiusSquared_","getCenter","computeExtent","circleExtent","intersectsCoordinate","bind","setCenter","offset","setRadius","rotate","angle","anchor","getStride","translate","deltaX","deltaY","transform","interpolatePoint","end","fraction","opt_dest","opt_dimension","o","t","x1","y1","length_1","cumulativeLengths","x2","y2","target","dimension","dest","NaN","lineStringCoordinateAtM","m","extrapolate","coordinate","lo","hi","mid","m0","lineStringsCoordinateAtM","ends","interpolate","draw","state","reactive","value","options","label","source","VectorSource","wrapX","vector","VectorLayer","style","Style","fill","Fill","color","stroke","Stroke","width","image","raster","TileLayer","XYZ","attributions","ATTRIBUTIONS","url","MAPURL","maxZoom","addInteraction","geometryFunction","maxPoints","setSource","createRegularPolygon","geometry","start","Polygon","Draw","handleChange","removeInteraction","onMounted","Map","layers","view","View","projection","zoom","addLayer","updateMapSize","__exports__","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","getLayout","polygons","endss","polygon","getEnds","jj","appendPolygon","len","newEndss","multiPolygon","getRevision","getOrientedFlatCoordinates","getArea","opt_right","orient","inflate","getEndss","getFlatInteriorPoints","flatCenters","linearRingss","getInteriorPoints","GeometryLayout","XYM","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","XY","getPolygon","prevEnds","getPolygons","deflate","lastEnds","SimpleGeometry","MultiLineString","opt_ends","ends_","lineStrings","lineString","appendLineString","multiLineString","getCoordinateAtM","opt_extrapolate","opt_interpolate","XYZM","getLineString","getLineStrings","getFlatMidpoints","midpoints","midpoint","simplifiedEnds","Mode","DrawEventType","DrawEvent","feature","pointerOptions","stopDown","on","once","un","shouldHandle_","downPx_","downTimeout_","lastDragTime_","pointerType_","freehand_","source_","features_","features","snapTolerance_","snapTolerance","type_","mode_","Error","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","Infinity","finishCondition_","finishCondition","geometryLayout_","geometryLayout","styles","Constructor_1","mode_1","squaredLength","userProjection","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","useSpatialIndex","resolution","getGeometry","updateWhileInteracting","geometryName_","geometryName","condition_","condition","freehandCondition_","freehand","freehandCondition","addChangeListener","ACTIVE","updateState_","setMap","getOverlay","handleEvent","event","originalEvent","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","Date","now","pixel","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","handleDownEvent","startDrawing_","setTimeout","frameState","handleUpEvent","startingToDraw","finishDrawing","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","mode","sketchCoords","getMap","finishCoordinate","finishPixel","getPixelFromCoordinate","updateSketchFeatures_","createOrUpdateCustomSketchLine_","ring","getLinearRing","sketchLineGeom","setGeometry","getView","getProjection","setGeometryName","dispatchEvent","last","done","pop","removeLastPoint","splice","sketchFeature","abortDrawing_","addFeature","getSource","clear","appendCoordinates","newDrawing","shift","ending","extend","sketchFeatures","overlaySource","addFeatures","active","getActive","opt_sides","opt_angle","opt_geometry","atan2","LineString","flatMidpoint_","flatMidpointRevision_","appendCoordinate","forEachSegment","callback","getCoordinateAt","getLength","getFlatMidpoint"],"mappings":"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","file":"js/chunk-b84a4ffc.9c7c35c2.js","sourcesContent":["import { onBeforeUnmount } from \"vue\";\n\n/**\n * 监听侧边栏，侧边栏发生变化更新地图\n * @param {ol.Map} map 地图实例\n */\nexport default (...map) => {\n  // 选择需要观察变动的节点\n  const targetNode = document.querySelector(\n    \".el-aside .menu .el-scrollbar__view\"\n  );\n  // 观察器的配置（需要观察什么变动）\n  const config = { attributes: true, childList: true, subtree: true };\n  // 当观察到变动时执行的回调函数\n  const callback = function (mutationsList) {\n    // Use traditional 'for loops' for IE 11\n    for (let mutation of mutationsList) {\n      if (mutation.type === \"childList\") {\n        // console.log(\"已添加或删除子节点。\");\n      } else if (\n        mutation.type === \"attributes\" &&\n        mutation.attributeName === \"style\"\n      ) {\n        for (let i = 0; i < map.length; i++) {\n          map[i].updateSize();\n        }\n\n        // console.log(\"这个 \" + mutation.attributeName + \" 属性被修改。\");\n      }\n    }\n  };\n  // 创建一个观察器实例并传入回调函数\n  const observer = new MutationObserver(callback);\n\n  // 以上述配置开始观察目标节点\n  observer.observe(targetNode, config);\n\n  //卸载前\n  onBeforeUnmount(() => {\n    observer.disconnect();\n  });\n};\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPoint\n */\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { closestSquaredDistanceXY, containsXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /** @class */ (function (_super) {\n    __extends(MultiPoint, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function MultiPoint(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed point to this multipoint.\n     * @param {Point} point Point.\n     * @api\n     */\n    MultiPoint.prototype.appendPoint = function (point) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = point.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, point.getFlatCoordinates());\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPoint} Clone.\n     * @api\n     */\n    MultiPoint.prototype.clone = function () {\n        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n        multiPoint.applyProperties(this);\n        return multiPoint;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var squaredDistance = squaredDx(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n            if (squaredDistance < minSquaredDistance) {\n                minSquaredDistance = squaredDistance;\n                for (var j = 0; j < stride; ++j) {\n                    closestPoint[j] = flatCoordinates[i + j];\n                }\n                closestPoint.length = stride;\n            }\n        }\n        return minSquaredDistance;\n    };\n    /**\n     * Return the coordinates of the multipoint.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    MultiPoint.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the point at the specified index.\n     * @param {number} index Index.\n     * @return {Point} Point.\n     * @api\n     */\n    MultiPoint.prototype.getPoint = function (index) {\n        var n = !this.flatCoordinates\n            ? 0\n            : this.flatCoordinates.length / this.stride;\n        if (index < 0 || n <= index) {\n            return null;\n        }\n        return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);\n    };\n    /**\n     * Return the points of this multipoint.\n     * @return {Array<Point>} Points.\n     * @api\n     */\n    MultiPoint.prototype.getPoints = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var layout = this.layout;\n        var stride = this.stride;\n        /** @type {Array<Point>} */\n        var points = [];\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n            points.push(point);\n        }\n        return points;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiPoint.prototype.getType = function () {\n        return 'MultiPoint';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPoint.prototype.intersectsExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            if (containsXY(extent, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Set the coordinates of the multipoint.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return MultiPoint;\n}(SimpleGeometry));\nexport default MultiPoint;\n//# sourceMappingURL=MultiPoint.js.map","export * from \"-!../../../../node_modules/.pnpm/mini-css-extract-plugin@0.9.0_webpack@4.47.0/node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../node_modules/.pnpm/css-loader@3.6.0_webpack@4.47.0/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/.pnpm/postcss-loader@3.0.0/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../node_modules/.pnpm/cache-loader@4.1.0_webpack@4.47.0/node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/index.js??ref--1-1!./index.vue?vue&type=style&index=0&id=6a68b341&scoped=true&lang=css\"","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { createOrUpdate, forEachCorner, intersects } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { rotate, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     *     For internal use, flat coordinates in combination with `opt_layout` and no\n     *     `opt_radius` are also accepted.\n     * @param {number} [opt_radius] Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function Circle(center, opt_radius, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout !== undefined && opt_radius === undefined) {\n            _this.setFlatCoordinates(opt_layout, center);\n        }\n        else {\n            var radius = opt_radius ? opt_radius : 0;\n            _this.setCenterAndRadius(center, radius, opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Circle} Clone.\n     * @api\n     */\n    Circle.prototype.clone = function () {\n        var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n        circle.applyProperties(this);\n        return circle;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        var squaredDistance = dx * dx + dy * dy;\n        if (squaredDistance < minSquaredDistance) {\n            if (squaredDistance === 0) {\n                for (var i = 0; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            else {\n                var delta = this.getRadius() / Math.sqrt(squaredDistance);\n                closestPoint[0] = flatCoordinates[0] + delta * dx;\n                closestPoint[1] = flatCoordinates[1] + delta * dy;\n                for (var i = 2; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            closestPoint.length = this.stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Circle.prototype.containsXY = function (x, y) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        return dx * dx + dy * dy <= this.getRadiusSquared_();\n    };\n    /**\n     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @return {import(\"../coordinate.js\").Coordinate} Center.\n     * @api\n     */\n    Circle.prototype.getCenter = function () {\n        return this.flatCoordinates.slice(0, this.stride);\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Circle.prototype.computeExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n        return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n    };\n    /**\n     * Return the radius of the circle.\n     * @return {number} Radius.\n     * @api\n     */\n    Circle.prototype.getRadius = function () {\n        return Math.sqrt(this.getRadiusSquared_());\n    };\n    /**\n     * @private\n     * @return {number} Radius squared.\n     */\n    Circle.prototype.getRadiusSquared_ = function () {\n        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n        return dx * dx + dy * dy;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    Circle.prototype.getType = function () {\n        return 'Circle';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Circle.prototype.intersectsExtent = function (extent) {\n        var circleExtent = this.getExtent();\n        if (intersects(extent, circleExtent)) {\n            var center = this.getCenter();\n            if (extent[0] <= center[0] && extent[2] >= center[0]) {\n                return true;\n            }\n            if (extent[1] <= center[1] && extent[3] >= center[1]) {\n                return true;\n            }\n            return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n        }\n        return false;\n    };\n    /**\n     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center.\n     * @api\n     */\n    Circle.prototype.setCenter = function (center) {\n        var stride = this.stride;\n        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n        var flatCoordinates = center.slice();\n        flatCoordinates[stride] = flatCoordinates[0] + radius;\n        for (var i = 1; i < stride; ++i) {\n            flatCoordinates[stride + i] = center[i];\n        }\n        this.setFlatCoordinates(this.layout, flatCoordinates);\n        this.changed();\n    };\n    /**\n     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n     * number) of the circle.\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     * @param {number} radius Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {\n        this.setLayout(opt_layout, center, 0);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        /** @type {Array<number>} */\n        var flatCoordinates = this.flatCoordinates;\n        var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n        flatCoordinates[offset++] = flatCoordinates[0] + radius;\n        for (var i = 1, ii = this.stride; i < ii; ++i) {\n            flatCoordinates[offset++] = flatCoordinates[i];\n        }\n        flatCoordinates.length = offset;\n        this.changed();\n    };\n    Circle.prototype.getCoordinates = function () {\n        return null;\n    };\n    Circle.prototype.setCoordinates = function (coordinates, opt_layout) { };\n    /**\n     * Set the radius of the circle. The radius is in the units of the projection.\n     * @param {number} radius Radius.\n     * @api\n     */\n    Circle.prototype.setRadius = function (radius) {\n        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n        this.changed();\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    Circle.prototype.rotate = function (angle, anchor) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(rotate(center, 0, center.length, stride, angle, anchor, center));\n        this.changed();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    Circle.prototype.translate = function (deltaX, deltaY) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));\n        this.changed();\n    };\n    return Circle;\n}(SimpleGeometry));\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n//# sourceMappingURL=Circle.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {\n    var o, t;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n        o = offset;\n    }\n    else if (n === 2) {\n        o = offset;\n        t = fraction;\n    }\n    else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length_1 = 0;\n        var cumulativeLengths = [0];\n        for (var i = offset + stride; i < end; i += stride) {\n            var x2 = flatCoordinates[i];\n            var y2 = flatCoordinates[i + 1];\n            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            cumulativeLengths.push(length_1);\n            x1 = x2;\n            y1 = y2;\n        }\n        var target = fraction * length_1;\n        var index = binarySearch(cumulativeLengths, target);\n        if (index < 0) {\n            t =\n                (target - cumulativeLengths[-index - 2]) /\n                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n            o = offset + (-index - 2) * stride;\n        }\n        else {\n            o = offset + index * stride;\n        }\n    }\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var dest = opt_dest ? opt_dest : new Array(dimension);\n    for (var i = 0; i < dimension; ++i) {\n        dest[i] =\n            o === undefined\n                ? NaN\n                : t === undefined\n                    ? flatCoordinates[o + i]\n                    : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n        return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(offset, offset + stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(end - stride, end);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n        var mid = (lo + hi) >> 1;\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(0, stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        if (offset == end) {\n            continue;\n        }\n        if (m < flatCoordinates[offset + stride - 1]) {\n            return null;\n        }\n        else if (m <= flatCoordinates[end - 1]) {\n            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n        offset = end;\n    }\n    return null;\n}\n//# sourceMappingURL=interpolate.js.map","<template>\n  <div id=\"menu\">\n    几何图形类型：\n    <el-select v-model=\"state.value\" size=\"large\" @change=\"handleChange\">\n      <el-option\n        v-for=\"item in state.options\"\n        :key=\"item.value\"\n        :label=\"item.label\"\n        :value=\"item.value\"\n      />\n    </el-select>\n  </div>\n  <div id=\"map\"></div>\n</template>\n\n<script setup>\n  import \"ol/ol.css\";\n  import { onMounted, reactive } from \"vue\";\n  import { Map, View } from \"ol\";\n  import { Tile as TileLayer, Vector as VectorLayer } from \"ol/layer\";\n  import { XYZ, Vector as VectorSource } from \"ol/source\";\n  import { Style, Fill, Stroke, Circle } from \"ol/style\";\n  import { Draw } from \"ol/interaction\";\n  import { createRegularPolygon } from \"ol/interaction/Draw\";\n  import { Polygon } from \"ol/geom\";\n  import { MAPURL, ATTRIBUTIONS } from \"@/constants\";\n  import updateMapSize from \"@/hooks/updateMapSize\";\n\n  let map = null;\n  let draw = null; // 绘制对象\n  const state = reactive({\n    value: \"Point\",\n    options: [\n      {\n        label: \"无\",\n        value: \"None\",\n      },\n      {\n        label: \"点\",\n        value: \"Point\",\n      },\n      {\n        label: \"线\",\n        value: \"LineString\",\n      },\n      {\n        label: \"多边形\",\n        value: \"Polygon\",\n      },\n      {\n        label: \"圆\",\n        value: \"Circle\",\n      },\n      {\n        label: \"正方形\",\n        value: \"Square\",\n      },\n      {\n        label: \"长方形\",\n        value: \"Box\",\n      },\n    ],\n  });\n  //实例化一个矢量图层Vector作为绘制层\n  let source = new VectorSource({ wrapX: false });\n  const vector = new VectorLayer({\n    source,\n    style: new Style({\n      fill: new Fill({\n        color: \"rgba(255, 255, 255, 0.2)\",\n      }),\n      stroke: new Stroke({\n        color: \"#ff0000\",\n        width: 2,\n      }),\n      image: new Circle({\n        radius: 7,\n        fill: new Fill({\n          color: \"#ff0000\",\n        }),\n      }),\n    }),\n  });\n\n  const raster = new TileLayer({\n    source: new XYZ({\n      attributions: ATTRIBUTIONS,\n      url: MAPURL,\n      maxZoom: 20,\n    }),\n  });\n\n  const initMap = () => {\n    map = new Map({\n      //初始化map\n      target: \"map\",\n      //地图容器中加载的图层\n      layers: [\n        //加载瓦片图层数据\n        raster,\n      ],\n      view: new View({\n        projection: \"EPSG:4326\", // 坐标系，有EPSG:4326和EPSG:3 857\n        center: [0, 0], // 深圳坐标\n        //地图初始显示级别\n        zoom: 5,\n      }),\n    });\n  };\n\n  //根据绘制类型进行交互绘制图形处理\n  const addInteraction = () => {\n    //绘制类型\n    let value = state.value;\n    if (value !== \"None\") {\n      if (source == null) {\n        source = new VectorSource({ wrapX: false });\n        //添加绘制层数据源\n        vector.setSource(source);\n      }\n      let geometryFunction, maxPoints;\n      if (value === \"Square\") {\n        value = \"Circle\";\n        //正方形图形（圆）\n        geometryFunction = createRegularPolygon(4);\n      } else if (value === \"Box\") {\n        value = \"LineString\";\n        maxPoints = 2;\n        geometryFunction = (coordinates, geometry) => {\n          var start = coordinates[0];\n          var end = coordinates[1];\n          if (!geometry) {\n            //多边形\n            geometry = new Polygon([\n              [start, [start[0], end[1]], end, [end[0], start[1]], start],\n            ]);\n          }\n          geometry.setCoordinates([\n            [start, [start[0], end[1]], end, [end[0], start[1]], start],\n          ]);\n          return geometry;\n        };\n      }\n      //实例化交互绘制类对象并添加到地图容器中\n      draw = new Draw({\n        //绘制层数据源\n        source: source,\n        /** @type {ol.geom.GeometryType}几何图形类型 */\n        type: value,\n        //几何信息变更时调用函数\n        geometryFunction: geometryFunction,\n        //最大点数\n        maxPoints: maxPoints,\n      });\n      map.addInteraction(draw);\n    } else {\n      source = null;\n      //清空绘制图形\n      vector.setSource(source);\n    }\n  };\n  const handleChange = () => {\n    //移除绘制图形\n    map.removeInteraction(draw);\n    //添加交互绘制功能控件\n    addInteraction();\n  };\n  onMounted(() => {\n    initMap();\n    //将绘制层添加到地图容器中\n    map.addLayer(vector);\n    //添加交互绘制功能控件\n    addInteraction();\n    // 侧边栏变化更新地图\n    updateMapSize(map);\n  });\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n  #map {\n    position: absolute;\n    top: 50px;\n    bottom: 0;\n    left: 0;\n    right: 0;\n  }\n  #menu {\n    height: 50px;\n    line-height: 50px;\n    text-align: center;\n  }\n</style>\n","import script from \"./index.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./index.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./index.vue?vue&type=style&index=0&id=6a68b341&scoped=true&lang=css\"\n\nimport exportComponent from \"/home/runner/work/openlayers/openlayers/node_modules/.pnpm/vue-loader@16.8.3_@vue+compiler-sfc@3.4.6_vue@3.4.6_webpack@4.47.0/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-6a68b341\"]])\n\nexport default __exports__","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta, } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray, } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /** @class */ (function (_super) {\n    __extends(MultiPolygon, _super);\n    /**\n     * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.\n     */\n    function MultiPolygon(coordinates, opt_layout, opt_endss) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        _this.endss_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointsRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.flatInteriorPoints_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (!opt_endss && !Array.isArray(coordinates[0])) {\n            var layout = _this.getLayout();\n            var polygons = /** @type {Array<Polygon>} */ (coordinates);\n            var flatCoordinates = [];\n            var endss = [];\n            for (var i = 0, ii = polygons.length; i < ii; ++i) {\n                var polygon = polygons[i];\n                if (i === 0) {\n                    layout = polygon.getLayout();\n                }\n                var offset = flatCoordinates.length;\n                var ends = polygon.getEnds();\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] += offset;\n                }\n                extend(flatCoordinates, polygon.getFlatCoordinates());\n                endss.push(ends);\n            }\n            opt_layout = layout;\n            coordinates = flatCoordinates;\n            opt_endss = endss;\n        }\n        if (opt_layout !== undefined && opt_endss) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.endss_ = opt_endss;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed polygon to this multipolygon.\n     * @param {Polygon} polygon Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.appendPolygon = function (polygon) {\n        /** @type {Array<number>} */\n        var ends;\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = polygon.getFlatCoordinates().slice();\n            ends = polygon.getEnds().slice();\n            this.endss_.push();\n        }\n        else {\n            var offset = this.flatCoordinates.length;\n            extend(this.flatCoordinates, polygon.getFlatCoordinates());\n            ends = polygon.getEnds().slice();\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] += offset;\n            }\n        }\n        this.endss_.push(ends);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPolygon} Clone.\n     * @api\n     */\n    MultiPolygon.prototype.clone = function () {\n        var len = this.endss_.length;\n        var newEndss = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            newEndss[i] = this.endss_[i].slice();\n        }\n        var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n        multiPolygon.applyProperties(this);\n        return multiPolygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    MultiPolygon.prototype.containsXY = function (x, y) {\n        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the multipolygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    MultiPolygon.prototype.getArea = function () {\n        return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for multi-polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n     * @api\n     */\n    MultiPolygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n    };\n    /**\n     * @return {Array<Array<number>>} Endss.\n     */\n    MultiPolygon.prototype.getEndss = function () {\n        return this.endss_;\n    };\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n    MultiPolygon.prototype.getFlatInteriorPoints = function () {\n        if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n            var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n            this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n            this.flatInteriorPointsRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoints_;\n    };\n    /**\n     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n     * @return {MultiPoint} Interior points as XYM coordinates, where M is\n     * the length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    MultiPolygon.prototype.getInteriorPoints = function () {\n        return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    MultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiPolygon} Simplified MultiPolygon.\n     * @protected\n     */\n    MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEndss = [];\n        simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n    };\n    /**\n     * Return the polygon at the specified index.\n     * @param {number} index Index.\n     * @return {Polygon} Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygon = function (index) {\n        if (index < 0 || this.endss_.length <= index) {\n            return null;\n        }\n        var offset;\n        if (index === 0) {\n            offset = 0;\n        }\n        else {\n            var prevEnds = this.endss_[index - 1];\n            offset = prevEnds[prevEnds.length - 1];\n        }\n        var ends = this.endss_[index].slice();\n        var end = ends[ends.length - 1];\n        if (offset !== 0) {\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] -= offset;\n            }\n        }\n        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n    };\n    /**\n     * Return the polygons of this multipolygon.\n     * @return {Array<Polygon>} Polygons.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygons = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var endss = this.endss_;\n        var polygons = [];\n        var offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var ends = endss[i].slice();\n            var end = ends[ends.length - 1];\n            if (offset !== 0) {\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] -= offset;\n                }\n            }\n            var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n            polygons.push(polygon);\n            offset = end;\n        }\n        return polygons;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiPolygon.prototype.getType = function () {\n        return 'MultiPolygon';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPolygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multipolygon.\n     * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 3);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n        if (endss.length === 0) {\n            this.flatCoordinates.length = 0;\n        }\n        else {\n            var lastEnds = endss[endss.length - 1];\n            this.flatCoordinates.length =\n                lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n        }\n        this.changed();\n    };\n    return MultiPolygon;\n}(SimpleGeometry));\nexport default MultiPolygon;\n//# sourceMappingURL=MultiPolygon.js.map","/**\n * @module ol/geom/flat/center\n */\nimport { createEmpty, createOrUpdateFromFlatCoordinates } from '../../extent.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n    var flatCenters = [];\n    var extent = createEmpty();\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n        offset = ends[ends.length - 1];\n    }\n    return flatCenters;\n}\n//# sourceMappingURL=center.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiLineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM, } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /** @class */ (function (_super) {\n    __extends(MultiLineString, _super);\n    /**\n     * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n     *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n     *     combination with `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n     */\n    function MultiLineString(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (Array.isArray(coordinates[0])) {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        else if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            var layout = _this.getLayout();\n            var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n            var flatCoordinates = [];\n            var ends = [];\n            for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n                var lineString = lineStrings[i];\n                if (i === 0) {\n                    layout = lineString.getLayout();\n                }\n                extend(flatCoordinates, lineString.getFlatCoordinates());\n                ends.push(flatCoordinates.length);\n            }\n            _this.setFlatCoordinates(layout, flatCoordinates);\n            _this.ends_ = ends;\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linestring to the multilinestring.\n     * @param {LineString} lineString LineString.\n     * @api\n     */\n    MultiLineString.prototype.appendLineString = function (lineString) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = lineString.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiLineString} Clone.\n     * @api\n     */\n    MultiLineString.prototype.clone = function () {\n        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        multiLineString.applyProperties(this);\n        return multiLineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * `opt_interpolate` controls interpolation between consecutive LineStrings\n     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n     * will be linearly interpolated between the last coordinate of one LineString\n     * and the first coordinate of the next LineString.  If `opt_interpolate` is\n     * `false` then the function will return `null` for Ms falling between\n     * LineStrings.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {\n        if ((this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) ||\n            this.flatCoordinates.length === 0) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n    };\n    /**\n     * Return the coordinates of the multilinestring.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinates = function () {\n        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    MultiLineString.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * Return the linestring at the specified index.\n     * @param {number} index Index.\n     * @return {LineString} LineString.\n     * @api\n     */\n    MultiLineString.prototype.getLineString = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linestrings of this multilinestring.\n     * @return {Array<LineString>} LineStrings.\n     * @api\n     */\n    MultiLineString.prototype.getLineStrings = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var layout = this.layout;\n        /** @type {Array<LineString>} */\n        var lineStrings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n            lineStrings.push(lineString);\n            offset = end;\n        }\n        return lineStrings;\n    };\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n    MultiLineString.prototype.getFlatMidpoints = function () {\n        var midpoints = [];\n        var flatCoordinates = this.flatCoordinates;\n        var offset = 0;\n        var ends = this.ends_;\n        var stride = this.stride;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n            extend(midpoints, midpoint);\n            offset = end;\n        }\n        return midpoints;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiLineString} Simplified MultiLineString.\n     * @protected\n     */\n    MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiLineString.prototype.getType = function () {\n        return 'MultiLineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiLineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multilinestring.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {GeometryLayout} [opt_layout] Layout.\n     * @api\n     */\n    MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return MultiLineString;\n}(SimpleGeometry));\nexport default MultiLineString;\n//# sourceMappingURL=MultiLineString.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { always, noModifierKeys, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight, } from '../extent.js';\nimport { createEditingStyle } from '../style/Style.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\nimport { squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\nvar Mode = {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    POLYGON: 'Polygon',\n    CIRCLE: 'Circle',\n};\n/**\n * @enum {string}\n */\nvar DrawEventType = {\n    /**\n     * Triggered upon feature draw start\n     * @event DrawEvent#drawstart\n     * @api\n     */\n    DRAWSTART: 'drawstart',\n    /**\n     * Triggered upon feature draw end\n     * @event DrawEvent#drawend\n     * @api\n     */\n    DRAWEND: 'drawend',\n    /**\n     * Triggered upon feature draw abortion\n     * @event DrawEvent#drawabort\n     * @api\n     */\n    DRAWABORT: 'drawabort',\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nvar DrawEvent = /** @class */ (function (_super) {\n    __extends(DrawEvent, _super);\n    /**\n     * @param {DrawEventType} type Type.\n     * @param {Feature} feature The feature drawn.\n     */\n    function DrawEvent(type, feature) {\n        var _this = _super.call(this, type) || this;\n        /**\n         * The feature being drawn.\n         * @type {Feature}\n         * @api\n         */\n        _this.feature = feature;\n        return _this;\n    }\n    return DrawEvent;\n}(Event));\nexport { DrawEvent };\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nvar Draw = /** @class */ (function (_super) {\n    __extends(Draw, _super);\n    /**\n     * @param {Options} options Options.\n     */\n    function Draw(options) {\n        var _this = this;\n        var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n        if (!pointerOptions.stopDown) {\n            pointerOptions.stopDown = FALSE;\n        }\n        _this = _super.call(this, pointerOptions) || this;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {DrawOnSignature<void>}\n         */\n        _this.un;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.shouldHandle_ = false;\n        /**\n         * @type {import(\"../pixel.js\").Pixel}\n         * @private\n         */\n        _this.downPx_ = null;\n        /**\n         * @type {?}\n         * @private\n         */\n        _this.downTimeout_;\n        /**\n         * @type {number|undefined}\n         * @private\n         */\n        _this.lastDragTime_;\n        /**\n         * Pointer type of the last pointermove event\n         * @type {string}\n         * @private\n         */\n        _this.pointerType_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.freehand_ = false;\n        /**\n         * Target source for drawn features.\n         * @type {VectorSource|null}\n         * @private\n         */\n        _this.source_ = options.source ? options.source : null;\n        /**\n         * Target collection for drawn features.\n         * @type {import(\"../Collection.js\").default<Feature>|null}\n         * @private\n         */\n        _this.features_ = options.features ? options.features : null;\n        /**\n         * Pixel distance for snapping.\n         * @type {number}\n         * @private\n         */\n        _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n        /**\n         * Geometry type.\n         * @type {import(\"../geom/Geometry.js\").Type}\n         * @private\n         */\n        _this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (options.type);\n        /**\n         * Drawing mode (derived from geometry type.\n         * @type {Mode}\n         * @private\n         */\n        _this.mode_ = getMode(_this.type_);\n        /**\n         * Stop click, singleclick, and doubleclick events from firing during drawing.\n         * Default is `false`.\n         * @type {boolean}\n         * @private\n         */\n        _this.stopClick_ = !!options.stopClick;\n        /**\n         * The number of points that must be drawn before a polygon ring or line\n         * string can be finished.  The default is 3 for polygon rings and 2 for\n         * line strings.\n         * @type {number}\n         * @private\n         */\n        _this.minPoints_ = options.minPoints\n            ? options.minPoints\n            : _this.mode_ === Mode.POLYGON\n                ? 3\n                : 2;\n        /**\n         * The number of points that can be drawn before a polygon ring or line string\n         * is finished. The default is no restriction.\n         * @type {number}\n         * @private\n         */\n        _this.maxPoints_ =\n            _this.mode_ === Mode.CIRCLE\n                ? 2\n                : options.maxPoints\n                    ? options.maxPoints\n                    : Infinity;\n        /**\n         * A function to decide if a potential finish coordinate is permissible\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.finishCondition_ = options.finishCondition\n            ? options.finishCondition\n            : TRUE;\n        /**\n         * @private\n         * @type {import(\"../geom/GeometryLayout\").default}\n         */\n        _this.geometryLayout_ = options.geometryLayout\n            ? options.geometryLayout\n            : GeometryLayout.XY;\n        var geometryFunction = options.geometryFunction;\n        if (!geometryFunction) {\n            var mode_1 = _this.mode_;\n            if (mode_1 === Mode.CIRCLE) {\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    var circle = geometry\n                        ? /** @type {Circle} */ (geometry)\n                        : new Circle([NaN, NaN]);\n                    var center = fromUserCoordinate(coordinates[0], projection);\n                    var squaredLength = squaredCoordinateDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));\n                    circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);\n                    var userProjection = getUserProjection();\n                    if (userProjection) {\n                        circle.transform(projection, userProjection);\n                    }\n                    return circle;\n                };\n            }\n            else {\n                var Constructor_1;\n                if (mode_1 === Mode.POINT) {\n                    Constructor_1 = Point;\n                }\n                else if (mode_1 === Mode.LINE_STRING) {\n                    Constructor_1 = LineString;\n                }\n                else if (mode_1 === Mode.POLYGON) {\n                    Constructor_1 = Polygon;\n                }\n                /**\n                 * @param {!LineCoordType} coordinates The coordinates.\n                 * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n                 * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n                 * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n                 */\n                geometryFunction = function (coordinates, geometry, projection) {\n                    if (geometry) {\n                        if (mode_1 === Mode.POLYGON) {\n                            if (coordinates[0].length) {\n                                // Add a closing coordinate to match the first\n                                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])], this.geometryLayout_);\n                            }\n                            else {\n                                geometry.setCoordinates([], this.geometryLayout_);\n                            }\n                        }\n                        else {\n                            geometry.setCoordinates(coordinates, this.geometryLayout_);\n                        }\n                    }\n                    else {\n                        geometry = new Constructor_1(coordinates, this.geometryLayout_);\n                    }\n                    return geometry;\n                };\n            }\n        }\n        /**\n         * @type {GeometryFunction}\n         * @private\n         */\n        _this.geometryFunction_ = geometryFunction;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.dragVertexDelay_ =\n            options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n        /**\n         * Finish coordinate for the feature (first point for polygons, last point for\n         * linestrings).\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.finishCoordinate_ = null;\n        /**\n         * Sketch feature.\n         * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n         * @private\n         */\n        _this.sketchFeature_ = null;\n        /**\n         * Sketch point.\n         * @type {Feature<Point>}\n         * @private\n         */\n        _this.sketchPoint_ = null;\n        /**\n         * Sketch coordinates. Used when drawing a line or polygon.\n         * @type {SketchCoordType}\n         * @private\n         */\n        _this.sketchCoords_ = null;\n        /**\n         * Sketch line. Used when drawing polygon.\n         * @type {Feature<LineString>}\n         * @private\n         */\n        _this.sketchLine_ = null;\n        /**\n         * Sketch line coordinates. Used when drawing a polygon or circle.\n         * @type {LineCoordType}\n         * @private\n         */\n        _this.sketchLineCoords_ = null;\n        /**\n         * Squared tolerance for handling up events.  If the squared distance\n         * between a down and up event is greater than this tolerance, up events\n         * will not be handled.\n         * @type {number}\n         * @private\n         */\n        _this.squaredClickTolerance_ = options.clickTolerance\n            ? options.clickTolerance * options.clickTolerance\n            : 36;\n        /**\n         * Draw overlay where our sketch features are drawn.\n         * @type {VectorLayer}\n         * @private\n         */\n        _this.overlay_ = new VectorLayer({\n            source: new VectorSource({\n                useSpatialIndex: false,\n                wrapX: options.wrapX ? options.wrapX : false,\n            }),\n            style: options.style ? options.style : getDefaultStyleFunction(),\n            updateWhileInteracting: true,\n        });\n        /**\n         * Name of the geometry attribute for newly created features.\n         * @type {string|undefined}\n         * @private\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.condition_ = options.condition ? options.condition : noModifierKeys;\n        /**\n         * @private\n         * @type {import(\"../events/condition.js\").Condition}\n         */\n        _this.freehandCondition_;\n        if (options.freehand) {\n            _this.freehandCondition_ = always;\n        }\n        else {\n            _this.freehandCondition_ = options.freehandCondition\n                ? options.freehandCondition\n                : shiftKeyOnly;\n        }\n        _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);\n        return _this;\n    }\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    Draw.prototype.setMap = function (map) {\n        _super.prototype.setMap.call(this, map);\n        this.updateState_();\n    };\n    /**\n     * Get the overlay layer that this interaction renders sketch features to.\n     * @return {VectorLayer} Overlay layer.\n     * @api\n     */\n    Draw.prototype.getOverlay = function () {\n        return this.overlay_;\n    };\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @api\n     */\n    Draw.prototype.handleEvent = function (event) {\n        if (event.originalEvent.type === EventType.CONTEXTMENU) {\n            // Avoid context menu for long taps when drawing on mobile\n            event.originalEvent.preventDefault();\n        }\n        this.freehand_ =\n            this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n        var move = event.type === MapBrowserEventType.POINTERMOVE;\n        var pass = true;\n        if (!this.freehand_ &&\n            this.lastDragTime_ &&\n            event.type === MapBrowserEventType.POINTERDRAG) {\n            var now = Date.now();\n            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n                this.downPx_ = event.pixel;\n                this.shouldHandle_ = !this.freehand_;\n                move = true;\n            }\n            else {\n                this.lastDragTime_ = undefined;\n            }\n            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n        }\n        if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDRAG &&\n            this.sketchFeature_ !== null) {\n            this.addToDrawing_(event.coordinate);\n            pass = false;\n        }\n        else if (this.freehand_ &&\n            event.type === MapBrowserEventType.POINTERDOWN) {\n            pass = false;\n        }\n        else if (move && this.getPointerCount() < 2) {\n            pass = event.type === MapBrowserEventType.POINTERMOVE;\n            if (pass && this.freehand_) {\n                this.handlePointerMove_(event);\n                if (this.shouldHandle_) {\n                    // Avoid page scrolling when freehand drawing on mobile\n                    event.originalEvent.preventDefault();\n                }\n            }\n            else if (event.originalEvent.pointerType === 'mouse' ||\n                (event.type === MapBrowserEventType.POINTERDRAG &&\n                    this.downTimeout_ === undefined)) {\n                this.handlePointerMove_(event);\n            }\n        }\n        else if (event.type === MapBrowserEventType.DBLCLICK) {\n            pass = false;\n        }\n        return _super.prototype.handleEvent.call(this, event) && pass;\n    };\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleDownEvent = function (event) {\n        this.shouldHandle_ = !this.freehand_;\n        if (this.freehand_) {\n            this.downPx_ = event.pixel;\n            if (!this.finishCoordinate_) {\n                this.startDrawing_(event.coordinate);\n            }\n            return true;\n        }\n        else if (this.condition_(event)) {\n            this.lastDragTime_ = Date.now();\n            this.downTimeout_ = setTimeout(function () {\n                this.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n            }.bind(this), this.dragVertexDelay_);\n            this.downPx_ = event.pixel;\n            return true;\n        }\n        else {\n            this.lastDragTime_ = undefined;\n            return false;\n        }\n    };\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n    Draw.prototype.handleUpEvent = function (event) {\n        var pass = true;\n        if (this.getPointerCount() === 0) {\n            if (this.downTimeout_) {\n                clearTimeout(this.downTimeout_);\n                this.downTimeout_ = undefined;\n            }\n            this.handlePointerMove_(event);\n            if (this.shouldHandle_) {\n                var startingToDraw = !this.finishCoordinate_;\n                if (startingToDraw) {\n                    this.startDrawing_(event.coordinate);\n                }\n                if (!startingToDraw && this.freehand_) {\n                    this.finishDrawing();\n                }\n                else if (!this.freehand_ &&\n                    (!startingToDraw || this.mode_ === Mode.POINT)) {\n                    if (this.atFinish_(event.pixel)) {\n                        if (this.finishCondition_(event)) {\n                            this.finishDrawing();\n                        }\n                    }\n                    else {\n                        this.addToDrawing_(event.coordinate);\n                    }\n                }\n                pass = false;\n            }\n            else if (this.freehand_) {\n                this.abortDrawing();\n            }\n        }\n        if (!pass && this.stopClick_) {\n            event.preventDefault();\n        }\n        return pass;\n    };\n    /**\n     * Handle move events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n     * @private\n     */\n    Draw.prototype.handlePointerMove_ = function (event) {\n        this.pointerType_ = event.originalEvent.pointerType;\n        if (this.downPx_ &&\n            ((!this.freehand_ && this.shouldHandle_) ||\n                (this.freehand_ && !this.shouldHandle_))) {\n            var downPx = this.downPx_;\n            var clickPx = event.pixel;\n            var dx = downPx[0] - clickPx[0];\n            var dy = downPx[1] - clickPx[1];\n            var squaredDistance = dx * dx + dy * dy;\n            this.shouldHandle_ = this.freehand_\n                ? squaredDistance > this.squaredClickTolerance_\n                : squaredDistance <= this.squaredClickTolerance_;\n            if (!this.shouldHandle_) {\n                return;\n            }\n        }\n        if (this.finishCoordinate_) {\n            this.modifyDrawing_(event.coordinate);\n        }\n        else {\n            this.createOrUpdateSketchPoint_(event.coordinate.slice());\n        }\n    };\n    /**\n     * Determine if an event is within the snapping tolerance of the start coord.\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @return {boolean} The event is within the snapping tolerance of the start.\n     * @private\n     */\n    Draw.prototype.atFinish_ = function (pixel) {\n        var at = false;\n        if (this.sketchFeature_) {\n            var potentiallyDone = false;\n            var potentiallyFinishCoordinates = [this.finishCoordinate_];\n            var mode = this.mode_;\n            if (mode === Mode.POINT) {\n                at = true;\n            }\n            else if (mode === Mode.CIRCLE) {\n                at = this.sketchCoords_.length === 2;\n            }\n            else if (mode === Mode.LINE_STRING) {\n                potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n            }\n            else if (mode === Mode.POLYGON) {\n                var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n                potentiallyDone = sketchCoords[0].length > this.minPoints_;\n                potentiallyFinishCoordinates = [\n                    sketchCoords[0][0],\n                    sketchCoords[0][sketchCoords[0].length - 2],\n                ];\n            }\n            if (potentiallyDone) {\n                var map = this.getMap();\n                for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n                    var finishCoordinate = potentiallyFinishCoordinates[i];\n                    var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n                    var dx = pixel[0] - finishPixel[0];\n                    var dy = pixel[1] - finishPixel[1];\n                    var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n                    if (at) {\n                        this.finishCoordinate_ = finishCoordinate;\n                        break;\n                    }\n                }\n            }\n        }\n        return at;\n    };\n    /**\n     * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n     * @private\n     */\n    Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {\n        if (!this.sketchPoint_) {\n            this.sketchPoint_ = new Feature(new Point(coordinates));\n            this.updateSketchFeatures_();\n        }\n        else {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinates);\n        }\n    };\n    /**\n     * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n     * @private\n     */\n    Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {\n        if (!this.sketchLine_) {\n            this.sketchLine_ = new Feature();\n        }\n        var ring = geometry.getLinearRing(0);\n        var sketchLineGeom = this.sketchLine_.getGeometry();\n        if (!sketchLineGeom) {\n            sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n            this.sketchLine_.setGeometry(sketchLineGeom);\n        }\n        else {\n            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n            sketchLineGeom.changed();\n        }\n    };\n    /**\n     * Start the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n     * @private\n     */\n    Draw.prototype.startDrawing_ = function (start) {\n        var projection = this.getMap().getView().getProjection();\n        var stride = getStrideForLayout(this.geometryLayout_);\n        while (start.length < stride) {\n            start.push(0);\n        }\n        this.finishCoordinate_ = start;\n        if (this.mode_ === Mode.POINT) {\n            this.sketchCoords_ = start.slice();\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            this.sketchCoords_ = [[start.slice(), start.slice()]];\n            this.sketchLineCoords_ = this.sketchCoords_[0];\n        }\n        else {\n            this.sketchCoords_ = [start.slice(), start.slice()];\n        }\n        if (this.sketchLineCoords_) {\n            this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n        }\n        var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);\n        this.sketchFeature_ = new Feature();\n        if (this.geometryName_) {\n            this.sketchFeature_.setGeometryName(this.geometryName_);\n        }\n        this.sketchFeature_.setGeometry(geometry);\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Modify the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @private\n     */\n    Draw.prototype.modifyDrawing_ = function (coordinate) {\n        var map = this.getMap();\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = map.getView().getProjection();\n        var stride = getStrideForLayout(this.geometryLayout_);\n        var coordinates, last;\n        while (coordinate.length < stride) {\n            coordinate.push(0);\n        }\n        if (this.mode_ === Mode.POINT) {\n            last = this.sketchCoords_;\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            last = coordinates[coordinates.length - 1];\n            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n                // snap to finish\n                coordinate = this.finishCoordinate_.slice();\n            }\n        }\n        else {\n            coordinates = this.sketchCoords_;\n            last = coordinates[coordinates.length - 1];\n        }\n        last[0] = coordinate[0];\n        last[1] = coordinate[1];\n        this.geometryFunction_(\n        /** @type {!LineCoordType} */ (this.sketchCoords_), geometry, projection);\n        if (this.sketchPoint_) {\n            var sketchPointGeom = this.sketchPoint_.getGeometry();\n            sketchPointGeom.setCoordinates(coordinate);\n        }\n        if (geometry.getType() === 'Polygon' && this.mode_ !== Mode.POLYGON) {\n            this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n        }\n        else if (this.sketchLineCoords_) {\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Add a new coordinate to the drawing.\n     * @param {!PointCoordType} coordinate Coordinate\n     * @private\n     */\n    Draw.prototype.addToDrawing_ = function (coordinate) {\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var done;\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            this.finishCoordinate_ = coordinate.slice();\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            if (coordinates.length >= this.maxPoints_) {\n                if (this.freehand_) {\n                    coordinates.pop();\n                }\n                else {\n                    done = true;\n                }\n            }\n            coordinates.push(coordinate.slice());\n            if (done) {\n                this.finishCoordinate_ = coordinates[0];\n            }\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        this.createOrUpdateSketchPoint_(coordinate.slice());\n        this.updateSketchFeatures_();\n        if (done) {\n            this.finishDrawing();\n        }\n    };\n    /**\n     * Remove last point of the feature currently being drawn. Does not do anything when\n     * drawing POINT or MULTI_POINT geometries.\n     * @api\n     */\n    Draw.prototype.removeLastPoint = function () {\n        if (!this.sketchFeature_) {\n            return;\n        }\n        var geometry = this.sketchFeature_.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        var coordinates;\n        var mode = this.mode_;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n            coordinates.splice(-2, 1);\n            if (coordinates.length >= 2) {\n                this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n                var finishCoordinate = this.finishCoordinate_.slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            this.geometryFunction_(coordinates, geometry, projection);\n            if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n                this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n            }\n        }\n        else if (mode === Mode.POLYGON) {\n            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n            coordinates.splice(-2, 1);\n            var sketchLineGeom = this.sketchLine_.getGeometry();\n            if (coordinates.length >= 2) {\n                var finishCoordinate = coordinates[coordinates.length - 2].slice();\n                coordinates[coordinates.length - 1] = finishCoordinate;\n                this.createOrUpdateSketchPoint_(finishCoordinate);\n            }\n            sketchLineGeom.setCoordinates(coordinates);\n            this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        if (coordinates.length === 1) {\n            this.abortDrawing();\n        }\n        this.updateSketchFeatures_();\n    };\n    /**\n     * Stop drawing and add the sketch feature to the target layer.\n     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n     * dispatched before inserting the feature.\n     * @api\n     */\n    Draw.prototype.finishDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (!sketchFeature) {\n            return;\n        }\n        var coordinates = this.sketchCoords_;\n        var geometry = sketchFeature.getGeometry();\n        var projection = this.getMap().getView().getProjection();\n        if (this.mode_ === Mode.LINE_STRING) {\n            // remove the redundant last point\n            coordinates.pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n        }\n        else if (this.mode_ === Mode.POLYGON) {\n            // remove the redundant last point in ring\n            /** @type {PolyCoordType} */ (coordinates)[0].pop();\n            this.geometryFunction_(coordinates, geometry, projection);\n            coordinates = geometry.getCoordinates();\n        }\n        // cast multi-part geometries\n        if (this.type_ === 'MultiPoint') {\n            sketchFeature.setGeometry(new MultiPoint([/** @type {PointCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === 'MultiLineString') {\n            sketchFeature.setGeometry(new MultiLineString([/** @type {LineCoordType} */ (coordinates)]));\n        }\n        else if (this.type_ === 'MultiPolygon') {\n            sketchFeature.setGeometry(new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]));\n        }\n        // First dispatch event to allow full set up of feature\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n        // Then insert feature\n        if (this.features_) {\n            this.features_.push(sketchFeature);\n        }\n        if (this.source_) {\n            this.source_.addFeature(sketchFeature);\n        }\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n     * @private\n     */\n    Draw.prototype.abortDrawing_ = function () {\n        this.finishCoordinate_ = null;\n        var sketchFeature = this.sketchFeature_;\n        this.sketchFeature_ = null;\n        this.sketchPoint_ = null;\n        this.sketchLine_ = null;\n        this.overlay_.getSource().clear(true);\n        return sketchFeature;\n    };\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @api\n     */\n    Draw.prototype.abortDrawing = function () {\n        var sketchFeature = this.abortDrawing_();\n        if (sketchFeature) {\n            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n        }\n    };\n    /**\n     * Append coordinates to the end of the geometry that is currently being drawn.\n     * This can be used when drawing LineStrings or Polygons. Coordinates will\n     * either be appended to the current LineString or the outer ring of the current\n     * Polygon. If no geometry is being drawn, a new one will be created.\n     * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n     * the coordinate array.\n     * @api\n     */\n    Draw.prototype.appendCoordinates = function (coordinates) {\n        var mode = this.mode_;\n        var newDrawing = !this.sketchFeature_;\n        if (newDrawing) {\n            this.startDrawing_(coordinates[0]);\n        }\n        /** @type {LineCoordType} */\n        var sketchCoords;\n        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {\n            sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n        }\n        else if (mode === Mode.POLYGON) {\n            sketchCoords =\n                this.sketchCoords_ && this.sketchCoords_.length\n                    ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n                    : [];\n        }\n        else {\n            return;\n        }\n        if (newDrawing) {\n            sketchCoords.shift();\n        }\n        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n        sketchCoords.pop();\n        // Append coordinate list\n        for (var i = 0; i < coordinates.length; i++) {\n            this.addToDrawing_(coordinates[i]);\n        }\n        var ending = coordinates[coordinates.length - 1];\n        // Duplicate last coordinate for sketch drawing (cursor position)\n        this.addToDrawing_(ending);\n        this.modifyDrawing_(ending);\n    };\n    /**\n     * Initiate draw mode by starting from an existing geometry which will\n     * receive new additional points. This only works on features with\n     * `LineString` geometries, where the interaction will extend lines by adding\n     * points to the end of the coordinates array.\n     * This will change the original feature, instead of drawing a copy.\n     *\n     * The function will dispatch a `drawstart` event.\n     *\n     * @param {!Feature<LineString>} feature Feature to be extended.\n     * @api\n     */\n    Draw.prototype.extend = function (feature) {\n        var geometry = feature.getGeometry();\n        var lineString = geometry;\n        this.sketchFeature_ = feature;\n        this.sketchCoords_ = lineString.getCoordinates();\n        var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n        this.finishCoordinate_ = last.slice();\n        this.sketchCoords_.push(last.slice());\n        this.sketchPoint_ = new Feature(new Point(last));\n        this.updateSketchFeatures_();\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    };\n    /**\n     * Redraw the sketch features.\n     * @private\n     */\n    Draw.prototype.updateSketchFeatures_ = function () {\n        var sketchFeatures = [];\n        if (this.sketchFeature_) {\n            sketchFeatures.push(this.sketchFeature_);\n        }\n        if (this.sketchLine_) {\n            sketchFeatures.push(this.sketchLine_);\n        }\n        if (this.sketchPoint_) {\n            sketchFeatures.push(this.sketchPoint_);\n        }\n        var overlaySource = this.overlay_.getSource();\n        overlaySource.clear(true);\n        overlaySource.addFeatures(sketchFeatures);\n    };\n    /**\n     * @private\n     */\n    Draw.prototype.updateState_ = function () {\n        var map = this.getMap();\n        var active = this.getActive();\n        if (!map || !active) {\n            this.abortDrawing();\n        }\n        this.overlay_.setMap(active ? map : null);\n    };\n    return Draw;\n}(PointerInteraction));\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n    var styles = createEditingStyle();\n    return function (feature, resolution) {\n        return styles[feature.getGeometry().getType()];\n    };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [opt_sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [opt_angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(opt_sides, opt_angle) {\n    return function (coordinates, opt_geometry, projection) {\n        var center = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[0], projection);\n        var end = fromUserCoordinate(\n        /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1], projection);\n        var radius = Math.sqrt(squaredCoordinateDistance(center, end));\n        var geometry = opt_geometry\n            ? /** @type {Polygon} */ (opt_geometry)\n            : fromCircle(new Circle(center), opt_sides);\n        var angle = opt_angle;\n        if (!opt_angle && opt_angle !== 0) {\n            var x = end[0] - center[0];\n            var y = end[1] - center[1];\n            angle = Math.atan2(y, x);\n        }\n        makeRegular(geometry, center, radius, angle);\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n    return function (coordinates, opt_geometry, projection) {\n        var extent = boundingExtent(\n        /** @type {LineCoordType} */ ([\n            coordinates[0],\n            coordinates[coordinates.length - 1],\n        ]).map(function (coordinate) {\n            return fromUserCoordinate(coordinate, projection);\n        }));\n        var boxCoordinates = [\n            [\n                getBottomLeft(extent),\n                getBottomRight(extent),\n                getTopRight(extent),\n                getTopLeft(extent),\n                getBottomLeft(extent),\n            ],\n        ];\n        var geometry = opt_geometry;\n        if (geometry) {\n            geometry.setCoordinates(boxCoordinates);\n        }\n        else {\n            geometry = new Polygon(boxCoordinates);\n        }\n        var userProjection = getUserProjection();\n        if (userProjection) {\n            geometry.transform(projection, userProjection);\n        }\n        return geometry;\n    };\n}\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n    switch (type) {\n        case 'Point':\n        case 'MultiPoint':\n            return Mode.POINT;\n        case 'LineString':\n        case 'MultiLineString':\n            return Mode.LINE_STRING;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return Mode.POLYGON;\n        case 'Circle':\n            return Mode.CIRCLE;\n        default:\n            throw new Error('Invalid type: ' + type);\n    }\n}\nexport default Draw;\n//# sourceMappingURL=Draw.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { forEach as forEachSegment } from './flat/segments.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { interpolatePoint, lineStringCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineString } from './flat/intersectsextent.js';\nimport { lineStringLength } from './flat/length.js';\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /** @class */ (function (_super) {\n    __extends(LineString, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function LineString(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatMidpoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatMidpointRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed coordinate to the coordinates of the linestring.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @api\n     */\n    LineString.prototype.appendCoordinate = function (coordinate) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = coordinate.slice();\n        }\n        else {\n            extend(this.flatCoordinates, coordinate);\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LineString} Clone.\n     * @api\n     */\n    LineString.prototype.clone = function () {\n        var lineString = new LineString(this.flatCoordinates.slice(), this.layout);\n        lineString.applyProperties(this);\n        return lineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Iterate over each segment, calling the provided callback.\n     * If the callback returns a truthy value the function returns that\n     * value immediately. Otherwise the function returns `false`.\n     *\n     * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n     * @return {T|boolean} Value.\n     * @template T,S\n     * @api\n     */\n    LineString.prototype.forEachSegment = function (callback) {\n        return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {\n        if (this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n    };\n    /**\n     * Return the coordinates of the linestring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LineString.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinate at the provided fraction along the linestring.\n     * The `fraction` is a number between 0 and 1, where 0 is the start of the\n     * linestring and 1 is the end.\n     * @param {number} fraction Fraction.\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_dest] Optional coordinate whose values will\n     *     be modified. If not provided, a new coordinate will be returned.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n     * @api\n     */\n    LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {\n        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);\n    };\n    /**\n     * Return the length of the linestring on projected plane.\n     * @return {number} Length (on projected plane).\n     * @api\n     */\n    LineString.prototype.getLength = function () {\n        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat midpoint.\n     */\n    LineString.prototype.getFlatMidpoint = function () {\n        if (this.flatMidpointRevision_ != this.getRevision()) {\n            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n            this.flatMidpointRevision_ = this.getRevision();\n        }\n        return this.flatMidpoint_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} Simplified LineString.\n     * @protected\n     */\n    LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    LineString.prototype.getType = function () {\n        return 'LineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the linestring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    LineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LineString;\n}(SimpleGeometry));\nexport default LineString;\n//# sourceMappingURL=LineString.js.map"],"sourceRoot":""}